/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _introAnimation = __webpack_require__(1);

	var _introAnimation2 = _interopRequireDefault(_introAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		_introAnimation2.default.init();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _dynamics = __webpack_require__(2);

	var _dynamics2 = _interopRequireDefault(_dynamics);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var body = document.querySelector('body');
	var logo = document.querySelector('[data-js-logo]');
	var title = document.querySelector('[data-js-title]');
	var twitterLink = document.querySelector('[data-js-twitter]');
	var githubLogo = document.querySelector('[data-js-github-logo] svg');

	_dynamics2.default.css(body, { scale: 1.1 });
	_dynamics2.default.css(logo, { opacity: 0, translateY: 15 });
	_dynamics2.default.css(title, { opacity: 0, translateY: -15 });
	_dynamics2.default.css(githubLogo, { opacity: 0, translateY: -15 });
	_dynamics2.default.css(twitterLink, { opacity: 0 });

	function animateContent() {
	  // Logo
	  _dynamics2.default.animate(logo, {
	    opacity: 1,
	    translateY: 0
	  }, {
	    delay: 50,
	    type: _dynamics2.default.spring
	  });

	  // Paragraph
	  _dynamics2.default.animate(title, {
	    opacity: 1,
	    translateY: 0
	  }, {
	    delay: 50,
	    type: _dynamics2.default.spring
	  });

	  // Github logo
	  _dynamics2.default.animate(githubLogo, {
	    opacity: 1,
	    translateY: 0
	  }, {
	    delay: 750,
	    type: _dynamics2.default.spring,
	    frequency: 140,
	    friction: 220
	  });

	  // Twitter link
	  _dynamics2.default.animate(twitterLink, {
	    opacity: 1
	  }, {
	    delay: 750,
	    type: _dynamics2.default.easeIn
	  });
	}

	function animateBody() {
	  // Body
	  _dynamics2.default.animate(body, {
	    opacity: 1,
	    scale: 1
	  }, {
	    duration: 1500,
	    type: _dynamics2.default.easeInOut,
	    complete: animateContent
	  });
	}

	exports.default = {
	  init: animateBody
		};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Generated by CoffeeScript 1.7.1
	(function () {
	  var Color,
	      DecomposedMatrix,
	      DecomposedMatrix2D,
	      InterpolableArray,
	      InterpolableColor,
	      InterpolableNumber,
	      InterpolableObject,
	      InterpolableString,
	      Matrix,
	      Matrix2D,
	      Set,
	      Vector,
	      addTimeout,
	      animationTick,
	      animations,
	      animationsTimeouts,
	      applyDefaults,
	      applyFrame,
	      applyProperties,
	      baseSVG,
	      cacheFn,
	      cancelTimeout,
	      clone,
	      createInterpolable,
	      defaultValueForKey,
	      degProperties,
	      dynamics,
	      getCurrentProperties,
	      interpolate,
	      isDocumentVisible,
	      isSVGElement,
	      lastTime,
	      leftDelayForTimeout,
	      makeArrayFn,
	      observeVisibilityChange,
	      parseProperties,
	      prefixFor,
	      propertyWithPrefix,
	      pxProperties,
	      rAF,
	      roundf,
	      runLoopPaused,
	      runLoopRunning,
	      _runLoopTick,
	      setRealTimeout,
	      slow,
	      slowRatio,
	      startAnimation,
	      startRunLoop,
	      svgProperties,
	      timeBeforeVisibilityChange,
	      timeoutLastId,
	      timeouts,
	      toDashed,
	      transformProperties,
	      transformValueForProperty,
	      unitForProperty,
	      __bind = function __bind(fn, me) {
	    return function () {
	      return fn.apply(me, arguments);
	    };
	  };

	  isDocumentVisible = function isDocumentVisible() {
	    return document.visibilityState === "visible" || dynamics.tests != null;
	  };

	  observeVisibilityChange = function () {
	    var fns;
	    fns = [];
	    if (typeof document !== "undefined" && document !== null) {
	      document.addEventListener("visibilitychange", function () {
	        var fn, _i, _len, _results;
	        _results = [];
	        for (_i = 0, _len = fns.length; _i < _len; _i++) {
	          fn = fns[_i];
	          _results.push(fn(isDocumentVisible()));
	        }
	        return _results;
	      });
	    }
	    return function (fn) {
	      return fns.push(fn);
	    };
	  }();

	  clone = function clone(o) {
	    var k, newO, v;
	    newO = {};
	    for (k in o) {
	      v = o[k];
	      newO[k] = v;
	    }
	    return newO;
	  };

	  cacheFn = function cacheFn(func) {
	    var data;
	    data = {};
	    return function () {
	      var k, key, result, _i, _len;
	      key = "";
	      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
	        k = arguments[_i];
	        key += k.toString() + ",";
	      }
	      result = data[key];
	      if (!result) {
	        data[key] = result = func.apply(this, arguments);
	      }
	      return result;
	    };
	  };

	  makeArrayFn = function makeArrayFn(fn) {
	    return function (el) {
	      var args, i, res;
	      if (el instanceof Array || el instanceof NodeList || el instanceof HTMLCollection) {
	        res = function () {
	          var _i, _ref, _results;
	          _results = [];
	          for (i = _i = 0, _ref = el.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	            args = Array.prototype.slice.call(arguments, 1);
	            args.splice(0, 0, el[i]);
	            _results.push(fn.apply(this, args));
	          }
	          return _results;
	        }.apply(this, arguments);
	        return res;
	      }
	      return fn.apply(this, arguments);
	    };
	  };

	  applyDefaults = function applyDefaults(options, defaults) {
	    var k, v, _results;
	    _results = [];
	    for (k in defaults) {
	      v = defaults[k];
	      _results.push(options[k] != null ? options[k] : options[k] = v);
	    }
	    return _results;
	  };

	  applyFrame = function applyFrame(el, properties) {
	    var k, v, _results;
	    if (el.style != null) {
	      return applyProperties(el, properties);
	    } else {
	      _results = [];
	      for (k in properties) {
	        v = properties[k];
	        _results.push(el[k] = v.format());
	      }
	      return _results;
	    }
	  };

	  applyProperties = function applyProperties(el, properties) {
	    var isSVG, k, matrix, transforms, v;
	    properties = parseProperties(properties);
	    transforms = [];
	    isSVG = isSVGElement(el);
	    for (k in properties) {
	      v = properties[k];
	      if (transformProperties.contains(k)) {
	        transforms.push([k, v]);
	      } else {
	        if (v.format != null) {
	          v = v.format();
	        }
	        if (typeof v === 'number') {
	          v = "" + v + unitForProperty(k, v);
	        }
	        if (isSVG && svgProperties.contains(k)) {
	          el.setAttribute(k, v);
	        } else {
	          el.style[propertyWithPrefix(k)] = v;
	        }
	      }
	    }
	    if (transforms.length > 0) {
	      if (isSVG) {
	        matrix = new Matrix2D();
	        matrix.applyProperties(transforms);
	        return el.setAttribute("transform", matrix.decompose().format());
	      } else {
	        v = transforms.map(function (transform) {
	          return transformValueForProperty(transform[0], transform[1]);
	        }).join(" ");
	        return el.style[propertyWithPrefix("transform")] = v;
	      }
	    }
	  };

	  isSVGElement = function isSVGElement(el) {
	    var _ref, _ref1;
	    if (typeof SVGElement !== "undefined" && SVGElement !== null && typeof SVGSVGElement !== "undefined" && SVGSVGElement !== null) {
	      return el instanceof SVGElement && !(el instanceof SVGSVGElement);
	    } else {
	      return (_ref = (_ref1 = dynamics.tests) != null ? typeof _ref1.isSVG === "function" ? _ref1.isSVG(el) : void 0 : void 0) != null ? _ref : false;
	    }
	  };

	  roundf = function roundf(v, decimal) {
	    var d;
	    d = Math.pow(10, decimal);
	    return Math.round(v * d) / d;
	  };

	  Set = function () {
	    function Set(array) {
	      var v, _i, _len;
	      this.obj = {};
	      for (_i = 0, _len = array.length; _i < _len; _i++) {
	        v = array[_i];
	        this.obj[v] = 1;
	      }
	    }

	    Set.prototype.contains = function (v) {
	      return this.obj[v] === 1;
	    };

	    return Set;
	  }();

	  toDashed = function toDashed(str) {
	    return str.replace(/([A-Z])/g, function ($1) {
	      return "-" + $1.toLowerCase();
	    });
	  };

	  pxProperties = new Set('marginTop,marginLeft,marginBottom,marginRight,paddingTop,paddingLeft,paddingBottom,paddingRight,top,left,bottom,right,translateX,translateY,translateZ,perspectiveX,perspectiveY,perspectiveZ,width,height,maxWidth,maxHeight,minWidth,minHeight,borderRadius'.split(','));

	  degProperties = new Set('rotate,rotateX,rotateY,rotateZ,skew,skewX,skewY,skewZ'.split(','));

	  transformProperties = new Set('translate,translateX,translateY,translateZ,scale,scaleX,scaleY,scaleZ,rotate,rotateX,rotateY,rotateZ,rotateC,rotateCX,rotateCY,skew,skewX,skewY,skewZ,perspective'.split(','));

	  svgProperties = new Set('accent-height,ascent,azimuth,baseFrequency,baseline-shift,bias,cx,cy,d,diffuseConstant,divisor,dx,dy,elevation,filterRes,fx,fy,gradientTransform,height,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,letter-spacing,limitingConeAngle,markerHeight,markerWidth,numOctaves,order,overline-position,overline-thickness,pathLength,points,pointsAtX,pointsAtY,pointsAtZ,r,radius,rx,ry,seed,specularConstant,specularExponent,stdDeviation,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,surfaceScale,target,targetX,targetY,transform,underline-position,underline-thickness,viewBox,width,x,x1,x2,y,y1,y2,z'.split(','));

	  unitForProperty = function unitForProperty(k, v) {
	    if (typeof v !== 'number') {
	      return '';
	    }
	    if (pxProperties.contains(k)) {
	      return 'px';
	    } else if (degProperties.contains(k)) {
	      return 'deg';
	    }
	    return '';
	  };

	  transformValueForProperty = function transformValueForProperty(k, v) {
	    var match, unit;
	    match = ("" + v).match(/^([0-9.-]*)([^0-9]*)$/);
	    if (match != null) {
	      v = match[1];
	      unit = match[2];
	    } else {
	      v = parseFloat(v);
	    }
	    v = roundf(parseFloat(v), 10);
	    if (unit == null || unit === "") {
	      unit = unitForProperty(k, v);
	    }
	    return "" + k + "(" + v + unit + ")";
	  };

	  parseProperties = function parseProperties(properties) {
	    var axis, match, parsed, property, value, _i, _len, _ref;
	    parsed = {};
	    for (property in properties) {
	      value = properties[property];
	      if (transformProperties.contains(property)) {
	        match = property.match(/(translate|rotateC|rotate|skew|scale|perspective)(X|Y|Z|)/);
	        if (match && match[2].length > 0) {
	          parsed[property] = value;
	        } else {
	          _ref = ['X', 'Y', 'Z'];
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            axis = _ref[_i];
	            parsed[match[1] + axis] = value;
	          }
	        }
	      } else {
	        parsed[property] = value;
	      }
	    }
	    return parsed;
	  };

	  defaultValueForKey = function defaultValueForKey(key) {
	    var v;
	    v = key === 'opacity' ? 1 : 0;
	    return "" + v + unitForProperty(key, v);
	  };

	  getCurrentProperties = function getCurrentProperties(el, keys) {
	    var isSVG, key, matrix, properties, style, v, _i, _j, _len, _len1, _ref;
	    properties = {};
	    isSVG = isSVGElement(el);
	    if (el.style != null) {
	      style = window.getComputedStyle(el, null);
	      for (_i = 0, _len = keys.length; _i < _len; _i++) {
	        key = keys[_i];
	        if (transformProperties.contains(key)) {
	          if (properties['transform'] == null) {
	            if (isSVG) {
	              matrix = new Matrix2D((_ref = el.transform.baseVal.consolidate()) != null ? _ref.matrix : void 0);
	            } else {
	              matrix = Matrix.fromTransform(style[propertyWithPrefix('transform')]);
	            }
	            properties['transform'] = matrix.decompose();
	          }
	        } else {
	          v = style[key];
	          if (v == null && svgProperties.contains(key)) {
	            v = el.getAttribute(key);
	          }
	          if (v === "" || v == null) {
	            v = defaultValueForKey(key);
	          }
	          properties[key] = createInterpolable(v);
	        }
	      }
	    } else {
	      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
	        key = keys[_j];
	        properties[key] = createInterpolable(el[key]);
	      }
	    }
	    return properties;
	  };

	  createInterpolable = function createInterpolable(value) {
	    var interpolable, klass, klasses, _i, _len;
	    klasses = [InterpolableArray, InterpolableObject, InterpolableNumber, InterpolableString];
	    for (_i = 0, _len = klasses.length; _i < _len; _i++) {
	      klass = klasses[_i];
	      interpolable = klass.create(value);
	      if (interpolable != null) {
	        return interpolable;
	      }
	    }
	    return null;
	  };

	  InterpolableString = function () {
	    function InterpolableString(parts) {
	      this.parts = parts;
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	    }

	    InterpolableString.prototype.interpolate = function (endInterpolable, t) {
	      var end, i, newParts, start, _i, _ref;
	      start = this.parts;
	      end = endInterpolable.parts;
	      newParts = [];
	      for (i = _i = 0, _ref = Math.min(start.length, end.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	        if (start[i].interpolate != null) {
	          newParts.push(start[i].interpolate(end[i], t));
	        } else {
	          newParts.push(start[i]);
	        }
	      }
	      return new InterpolableString(newParts);
	    };

	    InterpolableString.prototype.format = function () {
	      var parts;
	      parts = this.parts.map(function (val) {
	        if (val.format != null) {
	          return val.format();
	        } else {
	          return val;
	        }
	      });
	      return parts.join('');
	    };

	    InterpolableString.create = function (value) {
	      var index, match, matches, parts, re, type, types, _i, _j, _len, _len1;
	      value = "" + value;
	      matches = [];
	      types = [{
	        re: /(#[a-f\d]{3,6})/ig,
	        klass: InterpolableColor,
	        parse: function parse(v) {
	          return v;
	        }
	      }, {
	        re: /(rgba?\([0-9.]*, ?[0-9.]*, ?[0-9.]*(?:, ?[0-9.]*)?\))/ig,
	        klass: InterpolableColor,
	        parse: function parse(v) {
	          return v;
	        }
	      }, {
	        re: /([-+]?[\d.]+)/ig,
	        klass: InterpolableNumber,
	        parse: parseFloat
	      }];
	      for (_i = 0, _len = types.length; _i < _len; _i++) {
	        type = types[_i];
	        re = type.re;
	        while (match = re.exec(value)) {
	          matches.push({
	            index: match.index,
	            length: match[1].length,
	            interpolable: type.klass.create(type.parse(match[1]))
	          });
	        }
	      }
	      matches = matches.sort(function (a, b) {
	        return a.index > b.index;
	      });
	      parts = [];
	      index = 0;
	      for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
	        match = matches[_j];
	        if (match.index < index) {
	          continue;
	        }
	        if (match.index > index) {
	          parts.push(value.substring(index, match.index));
	        }
	        parts.push(match.interpolable);
	        index = match.index + match.length;
	      }
	      if (index < value.length) {
	        parts.push(value.substring(index));
	      }
	      return new InterpolableString(parts);
	    };

	    return InterpolableString;
	  }();

	  InterpolableObject = function () {
	    function InterpolableObject(obj) {
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	      this.obj = obj;
	    }

	    InterpolableObject.prototype.interpolate = function (endInterpolable, t) {
	      var end, k, newObj, start, v;
	      start = this.obj;
	      end = endInterpolable.obj;
	      newObj = {};
	      for (k in start) {
	        v = start[k];
	        if (v.interpolate != null) {
	          newObj[k] = v.interpolate(end[k], t);
	        } else {
	          newObj[k] = v;
	        }
	      }
	      return new InterpolableObject(newObj);
	    };

	    InterpolableObject.prototype.format = function () {
	      return this.obj;
	    };

	    InterpolableObject.create = function (value) {
	      var k, obj, v;
	      if (value instanceof Object) {
	        obj = {};
	        for (k in value) {
	          v = value[k];
	          obj[k] = createInterpolable(v);
	        }
	        return new InterpolableObject(obj);
	      }
	      return null;
	    };

	    return InterpolableObject;
	  }();

	  InterpolableNumber = function () {
	    function InterpolableNumber(value) {
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	      this.value = parseFloat(value);
	    }

	    InterpolableNumber.prototype.interpolate = function (endInterpolable, t) {
	      var end, start;
	      start = this.value;
	      end = endInterpolable.value;
	      return new InterpolableNumber((end - start) * t + start);
	    };

	    InterpolableNumber.prototype.format = function () {
	      return roundf(this.value, 5);
	    };

	    InterpolableNumber.create = function (value) {
	      if (typeof value === 'number') {
	        return new InterpolableNumber(value);
	      }
	      return null;
	    };

	    return InterpolableNumber;
	  }();

	  InterpolableArray = function () {
	    function InterpolableArray(values) {
	      this.values = values;
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	    }

	    InterpolableArray.prototype.interpolate = function (endInterpolable, t) {
	      var end, i, newValues, start, _i, _ref;
	      start = this.values;
	      end = endInterpolable.values;
	      newValues = [];
	      for (i = _i = 0, _ref = Math.min(start.length, end.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	        if (start[i].interpolate != null) {
	          newValues.push(start[i].interpolate(end[i], t));
	        } else {
	          newValues.push(start[i]);
	        }
	      }
	      return new InterpolableArray(newValues);
	    };

	    InterpolableArray.prototype.format = function () {
	      return this.values.map(function (val) {
	        if (val.format != null) {
	          return val.format();
	        } else {
	          return val;
	        }
	      });
	    };

	    InterpolableArray.createFromArray = function (arr) {
	      var values;
	      values = arr.map(function (val) {
	        return createInterpolable(val) || val;
	      });
	      values = values.filter(function (val) {
	        return val != null;
	      });
	      return new InterpolableArray(values);
	    };

	    InterpolableArray.create = function (value) {
	      if (value instanceof Array) {
	        return InterpolableArray.createFromArray(value);
	      }
	      return null;
	    };

	    return InterpolableArray;
	  }();

	  Color = function () {
	    function Color(rgb, format) {
	      this.rgb = rgb != null ? rgb : {};
	      this.format = format;
	      this.toRgba = __bind(this.toRgba, this);
	      this.toRgb = __bind(this.toRgb, this);
	      this.toHex = __bind(this.toHex, this);
	    }

	    Color.fromHex = function (hex) {
	      var hex3, result;
	      hex3 = hex.match(/^#([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i);
	      if (hex3 != null) {
	        hex = "#" + hex3[1] + hex3[1] + hex3[2] + hex3[2] + hex3[3] + hex3[3];
	      }
	      result = hex.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
	      if (result != null) {
	        return new Color({
	          r: parseInt(result[1], 16),
	          g: parseInt(result[2], 16),
	          b: parseInt(result[3], 16),
	          a: 1
	        }, "hex");
	      }
	      return null;
	    };

	    Color.fromRgb = function (rgb) {
	      var match, _ref;
	      match = rgb.match(/^rgba?\(([0-9.]*), ?([0-9.]*), ?([0-9.]*)(?:, ?([0-9.]*))?\)$/);
	      if (match != null) {
	        return new Color({
	          r: parseFloat(match[1]),
	          g: parseFloat(match[2]),
	          b: parseFloat(match[3]),
	          a: parseFloat((_ref = match[4]) != null ? _ref : 1)
	        }, match[4] != null ? "rgba" : "rgb");
	      }
	      return null;
	    };

	    Color.componentToHex = function (c) {
	      var hex;
	      hex = c.toString(16);
	      if (hex.length === 1) {
	        return "0" + hex;
	      } else {
	        return hex;
	      }
	    };

	    Color.prototype.toHex = function () {
	      return "#" + Color.componentToHex(this.rgb.r) + Color.componentToHex(this.rgb.g) + Color.componentToHex(this.rgb.b);
	    };

	    Color.prototype.toRgb = function () {
	      return "rgb(" + this.rgb.r + ", " + this.rgb.g + ", " + this.rgb.b + ")";
	    };

	    Color.prototype.toRgba = function () {
	      return "rgba(" + this.rgb.r + ", " + this.rgb.g + ", " + this.rgb.b + ", " + this.rgb.a + ")";
	    };

	    return Color;
	  }();

	  InterpolableColor = function () {
	    function InterpolableColor(color) {
	      this.color = color;
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	    }

	    InterpolableColor.prototype.interpolate = function (endInterpolable, t) {
	      var end, k, rgb, start, v, _i, _len, _ref;
	      start = this.color;
	      end = endInterpolable.color;
	      rgb = {};
	      _ref = ['r', 'g', 'b'];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        k = _ref[_i];
	        v = Math.round((end.rgb[k] - start.rgb[k]) * t + start.rgb[k]);
	        rgb[k] = Math.min(255, Math.max(0, v));
	      }
	      k = "a";
	      v = roundf((end.rgb[k] - start.rgb[k]) * t + start.rgb[k], 5);
	      rgb[k] = Math.min(1, Math.max(0, v));
	      return new InterpolableColor(new Color(rgb, end.format));
	    };

	    InterpolableColor.prototype.format = function () {
	      if (this.color.format === "hex") {
	        return this.color.toHex();
	      } else if (this.color.format === "rgb") {
	        return this.color.toRgb();
	      } else if (this.color.format === "rgba") {
	        return this.color.toRgba();
	      }
	    };

	    InterpolableColor.create = function (value) {
	      var color;
	      if (typeof value !== "string") {
	        return;
	      }
	      color = Color.fromHex(value) || Color.fromRgb(value);
	      if (color != null) {
	        return new InterpolableColor(color);
	      }
	      return null;
	    };

	    return InterpolableColor;
	  }();

	  DecomposedMatrix2D = function () {
	    function DecomposedMatrix2D(props) {
	      this.props = props;
	      this.applyRotateCenter = __bind(this.applyRotateCenter, this);
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	    }

	    DecomposedMatrix2D.prototype.interpolate = function (endMatrix, t) {
	      var i, k, newProps, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;
	      newProps = {};
	      _ref = ['translate', 'scale', 'rotate'];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        k = _ref[_i];
	        newProps[k] = [];
	        for (i = _j = 0, _ref1 = this.props[k].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
	          newProps[k][i] = (endMatrix.props[k][i] - this.props[k][i]) * t + this.props[k][i];
	        }
	      }
	      for (i = _k = 1; _k <= 2; i = ++_k) {
	        newProps['rotate'][i] = endMatrix.props['rotate'][i];
	      }
	      _ref2 = ['skew'];
	      for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {
	        k = _ref2[_l];
	        newProps[k] = (endMatrix.props[k] - this.props[k]) * t + this.props[k];
	      }
	      return new DecomposedMatrix2D(newProps);
	    };

	    DecomposedMatrix2D.prototype.format = function () {
	      return "translate(" + this.props.translate.join(',') + ") rotate(" + this.props.rotate.join(',') + ") skewX(" + this.props.skew + ") scale(" + this.props.scale.join(',') + ")";
	    };

	    DecomposedMatrix2D.prototype.applyRotateCenter = function (rotateC) {
	      var i, m, m2d, negativeTranslate, _i, _results;
	      m = baseSVG.createSVGMatrix();
	      m = m.translate(rotateC[0], rotateC[1]);
	      m = m.rotate(this.props.rotate[0]);
	      m = m.translate(-rotateC[0], -rotateC[1]);
	      m2d = new Matrix2D(m);
	      negativeTranslate = m2d.decompose().props.translate;
	      _results = [];
	      for (i = _i = 0; _i <= 1; i = ++_i) {
	        _results.push(this.props.translate[i] -= negativeTranslate[i]);
	      }
	      return _results;
	    };

	    return DecomposedMatrix2D;
	  }();

	  baseSVG = typeof document !== "undefined" && document !== null ? document.createElementNS("http://www.w3.org/2000/svg", "svg") : void 0;

	  Matrix2D = function () {
	    function Matrix2D(m) {
	      this.m = m;
	      this.applyProperties = __bind(this.applyProperties, this);
	      this.decompose = __bind(this.decompose, this);
	      if (!this.m) {
	        this.m = baseSVG.createSVGMatrix();
	      }
	    }

	    Matrix2D.prototype.decompose = function () {
	      var kx, ky, kz, r0, r1;
	      r0 = new Vector([this.m.a, this.m.b]);
	      r1 = new Vector([this.m.c, this.m.d]);
	      kx = r0.length();
	      kz = r0.dot(r1);
	      r0 = r0.normalize();
	      ky = r1.combine(r0, 1, -kz).length();
	      return new DecomposedMatrix2D({
	        translate: [this.m.e, this.m.f],
	        rotate: [Math.atan2(this.m.b, this.m.a) * 180 / Math.PI, this.rotateCX, this.rotateCY],
	        scale: [kx, ky],
	        skew: kz / ky * 180 / Math.PI
	      });
	    };

	    Matrix2D.prototype.applyProperties = function (properties) {
	      var hash, k, props, v, _i, _len, _ref, _ref1;
	      hash = {};
	      for (_i = 0, _len = properties.length; _i < _len; _i++) {
	        props = properties[_i];
	        hash[props[0]] = props[1];
	      }
	      for (k in hash) {
	        v = hash[k];
	        if (k === "translateX") {
	          this.m = this.m.translate(v, 0);
	        } else if (k === "translateY") {
	          this.m = this.m.translate(0, v);
	        } else if (k === "scaleX") {
	          this.m = this.m.scale(v, 1);
	        } else if (k === "scaleY") {
	          this.m = this.m.scale(1, v);
	        } else if (k === "rotateZ") {
	          this.m = this.m.rotate(v);
	        } else if (k === "skewX") {
	          this.m = this.m.skewX(v);
	        } else if (k === "skewY") {
	          this.m = this.m.skewY(v);
	        }
	      }
	      this.rotateCX = (_ref = hash.rotateCX) != null ? _ref : 0;
	      return this.rotateCY = (_ref1 = hash.rotateCY) != null ? _ref1 : 0;
	    };

	    return Matrix2D;
	  }();

	  Vector = function () {
	    function Vector(els) {
	      this.els = els;
	      this.combine = __bind(this.combine, this);
	      this.normalize = __bind(this.normalize, this);
	      this.length = __bind(this.length, this);
	      this.cross = __bind(this.cross, this);
	      this.dot = __bind(this.dot, this);
	      this.e = __bind(this.e, this);
	    }

	    Vector.prototype.e = function (i) {
	      if (i < 1 || i > this.els.length) {
	        return null;
	      } else {
	        return this.els[i - 1];
	      }
	    };

	    Vector.prototype.dot = function (vector) {
	      var V, n, product;
	      V = vector.els || vector;
	      product = 0;
	      n = this.els.length;
	      if (n !== V.length) {
	        return null;
	      }
	      n += 1;
	      while (--n) {
	        product += this.els[n - 1] * V[n - 1];
	      }
	      return product;
	    };

	    Vector.prototype.cross = function (vector) {
	      var A, B;
	      B = vector.els || vector;
	      if (this.els.length !== 3 || B.length !== 3) {
	        return null;
	      }
	      A = this.els;
	      return new Vector([A[1] * B[2] - A[2] * B[1], A[2] * B[0] - A[0] * B[2], A[0] * B[1] - A[1] * B[0]]);
	    };

	    Vector.prototype.length = function () {
	      var a, e, _i, _len, _ref;
	      a = 0;
	      _ref = this.els;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        e = _ref[_i];
	        a += Math.pow(e, 2);
	      }
	      return Math.sqrt(a);
	    };

	    Vector.prototype.normalize = function () {
	      var e, i, length, newElements, _ref;
	      length = this.length();
	      newElements = [];
	      _ref = this.els;
	      for (i in _ref) {
	        e = _ref[i];
	        newElements[i] = e / length;
	      }
	      return new Vector(newElements);
	    };

	    Vector.prototype.combine = function (b, ascl, bscl) {
	      var i, result, _i, _ref;
	      result = [];
	      for (i = _i = 0, _ref = this.els.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	        result[i] = ascl * this.els[i] + bscl * b.els[i];
	      }
	      return new Vector(result);
	    };

	    return Vector;
	  }();

	  DecomposedMatrix = function () {
	    function DecomposedMatrix() {
	      this.toMatrix = __bind(this.toMatrix, this);
	      this.format = __bind(this.format, this);
	      this.interpolate = __bind(this.interpolate, this);
	    }

	    DecomposedMatrix.prototype.interpolate = function (decomposedB, t, only) {
	      var angle, decomposed, decomposedA, i, invscale, invth, k, qa, qb, scale, th, _i, _j, _k, _l, _len, _ref, _ref1;
	      if (only == null) {
	        only = null;
	      }
	      decomposedA = this;
	      decomposed = new DecomposedMatrix();
	      _ref = ['translate', 'scale', 'skew', 'perspective'];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        k = _ref[_i];
	        decomposed[k] = [];
	        for (i = _j = 0, _ref1 = decomposedA[k].length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
	          if (only == null || only.indexOf(k) > -1 || only.indexOf("" + k + ['x', 'y', 'z'][i]) > -1) {
	            decomposed[k][i] = (decomposedB[k][i] - decomposedA[k][i]) * t + decomposedA[k][i];
	          } else {
	            decomposed[k][i] = decomposedA[k][i];
	          }
	        }
	      }
	      if (only == null || only.indexOf('rotate') !== -1) {
	        qa = decomposedA.quaternion;
	        qb = decomposedB.quaternion;
	        angle = qa[0] * qb[0] + qa[1] * qb[1] + qa[2] * qb[2] + qa[3] * qb[3];
	        if (angle < 0.0) {
	          for (i = _k = 0; _k <= 3; i = ++_k) {
	            qa[i] = -qa[i];
	          }
	          angle = -angle;
	        }
	        if (angle + 1.0 > .05) {
	          if (1.0 - angle >= .05) {
	            th = Math.acos(angle);
	            invth = 1.0 / Math.sin(th);
	            scale = Math.sin(th * (1.0 - t)) * invth;
	            invscale = Math.sin(th * t) * invth;
	          } else {
	            scale = 1.0 - t;
	            invscale = t;
	          }
	        } else {
	          qb[0] = -qa[1];
	          qb[1] = qa[0];
	          qb[2] = -qa[3];
	          qb[3] = qa[2];
	          scale = Math.sin(piDouble * (.5 - t));
	          invscale = Math.sin(piDouble * t);
	        }
	        decomposed.quaternion = [];
	        for (i = _l = 0; _l <= 3; i = ++_l) {
	          decomposed.quaternion[i] = qa[i] * scale + qb[i] * invscale;
	        }
	      } else {
	        decomposed.quaternion = decomposedA.quaternion;
	      }
	      return decomposed;
	    };

	    DecomposedMatrix.prototype.format = function () {
	      return this.toMatrix().toString();
	    };

	    DecomposedMatrix.prototype.toMatrix = function () {
	      var decomposedMatrix, i, j, match, matrix, quaternion, skew, temp, w, x, y, z, _i, _j, _k, _l;
	      decomposedMatrix = this;
	      matrix = Matrix.I(4);
	      for (i = _i = 0; _i <= 3; i = ++_i) {
	        matrix.els[i][3] = decomposedMatrix.perspective[i];
	      }
	      quaternion = decomposedMatrix.quaternion;
	      x = quaternion[0];
	      y = quaternion[1];
	      z = quaternion[2];
	      w = quaternion[3];
	      skew = decomposedMatrix.skew;
	      match = [[1, 0], [2, 0], [2, 1]];
	      for (i = _j = 2; _j >= 0; i = --_j) {
	        if (skew[i]) {
	          temp = Matrix.I(4);
	          temp.els[match[i][0]][match[i][1]] = skew[i];
	          matrix = matrix.multiply(temp);
	        }
	      }
	      matrix = matrix.multiply(new Matrix([[1 - 2 * (y * y + z * z), 2 * (x * y - z * w), 2 * (x * z + y * w), 0], [2 * (x * y + z * w), 1 - 2 * (x * x + z * z), 2 * (y * z - x * w), 0], [2 * (x * z - y * w), 2 * (y * z + x * w), 1 - 2 * (x * x + y * y), 0], [0, 0, 0, 1]]));
	      for (i = _k = 0; _k <= 2; i = ++_k) {
	        for (j = _l = 0; _l <= 2; j = ++_l) {
	          matrix.els[i][j] *= decomposedMatrix.scale[i];
	        }
	        matrix.els[3][i] = decomposedMatrix.translate[i];
	      }
	      return matrix;
	    };

	    return DecomposedMatrix;
	  }();

	  Matrix = function () {
	    function Matrix(els) {
	      this.els = els;
	      this.toString = __bind(this.toString, this);
	      this.decompose = __bind(this.decompose, this);
	      this.inverse = __bind(this.inverse, this);
	      this.augment = __bind(this.augment, this);
	      this.toRightTriangular = __bind(this.toRightTriangular, this);
	      this.transpose = __bind(this.transpose, this);
	      this.multiply = __bind(this.multiply, this);
	      this.dup = __bind(this.dup, this);
	      this.e = __bind(this.e, this);
	    }

	    Matrix.prototype.e = function (i, j) {
	      if (i < 1 || i > this.els.length || j < 1 || j > this.els[0].length) {
	        return null;
	      }
	      return this.els[i - 1][j - 1];
	    };

	    Matrix.prototype.dup = function () {
	      return new Matrix(this.els);
	    };

	    Matrix.prototype.multiply = function (matrix) {
	      var M, c, cols, elements, i, j, ki, kj, nc, ni, nj, returnVector, sum;
	      returnVector = matrix.modulus ? true : false;
	      M = matrix.els || matrix;
	      if (typeof M[0][0] === 'undefined') {
	        M = new Matrix(M).els;
	      }
	      ni = this.els.length;
	      ki = ni;
	      kj = M[0].length;
	      cols = this.els[0].length;
	      elements = [];
	      ni += 1;
	      while (--ni) {
	        i = ki - ni;
	        elements[i] = [];
	        nj = kj;
	        nj += 1;
	        while (--nj) {
	          j = kj - nj;
	          sum = 0;
	          nc = cols;
	          nc += 1;
	          while (--nc) {
	            c = cols - nc;
	            sum += this.els[i][c] * M[c][j];
	          }
	          elements[i][j] = sum;
	        }
	      }
	      M = new Matrix(elements);
	      if (returnVector) {
	        return M.col(1);
	      } else {
	        return M;
	      }
	    };

	    Matrix.prototype.transpose = function () {
	      var cols, elements, i, j, ni, nj, rows;
	      rows = this.els.length;
	      cols = this.els[0].length;
	      elements = [];
	      ni = cols;
	      ni += 1;
	      while (--ni) {
	        i = cols - ni;
	        elements[i] = [];
	        nj = rows;
	        nj += 1;
	        while (--nj) {
	          j = rows - nj;
	          elements[i][j] = this.els[j][i];
	        }
	      }
	      return new Matrix(elements);
	    };

	    Matrix.prototype.toRightTriangular = function () {
	      var M, els, i, j, k, kp, multiplier, n, np, p, _i, _j, _ref, _ref1;
	      M = this.dup();
	      n = this.els.length;
	      k = n;
	      kp = this.els[0].length;
	      while (--n) {
	        i = k - n;
	        if (M.els[i][i] === 0) {
	          for (j = _i = _ref = i + 1; _ref <= k ? _i < k : _i > k; j = _ref <= k ? ++_i : --_i) {
	            if (M.els[j][i] !== 0) {
	              els = [];
	              np = kp;
	              np += 1;
	              while (--np) {
	                p = kp - np;
	                els.push(M.els[i][p] + M.els[j][p]);
	              }
	              M.els[i] = els;
	              break;
	            }
	          }
	        }
	        if (M.els[i][i] !== 0) {
	          for (j = _j = _ref1 = i + 1; _ref1 <= k ? _j < k : _j > k; j = _ref1 <= k ? ++_j : --_j) {
	            multiplier = M.els[j][i] / M.els[i][i];
	            els = [];
	            np = kp;
	            np += 1;
	            while (--np) {
	              p = kp - np;
	              els.push(p <= i ? 0 : M.els[j][p] - M.els[i][p] * multiplier);
	            }
	            M.els[j] = els;
	          }
	        }
	      }
	      return M;
	    };

	    Matrix.prototype.augment = function (matrix) {
	      var M, T, cols, i, j, ki, kj, ni, nj;
	      M = matrix.els || matrix;
	      if (typeof M[0][0] === 'undefined') {
	        M = new Matrix(M).els;
	      }
	      T = this.dup();
	      cols = T.els[0].length;
	      ni = T.els.length;
	      ki = ni;
	      kj = M[0].length;
	      if (ni !== M.length) {
	        return null;
	      }
	      ni += 1;
	      while (--ni) {
	        i = ki - ni;
	        nj = kj;
	        nj += 1;
	        while (--nj) {
	          j = kj - nj;
	          T.els[i][cols + j] = M[i][j];
	        }
	      }
	      return T;
	    };

	    Matrix.prototype.inverse = function () {
	      var M, divisor, els, i, inverse_elements, j, ki, kp, new_element, ni, np, p, _i;
	      ni = this.els.length;
	      ki = ni;
	      M = this.augment(Matrix.I(ni)).toRightTriangular();
	      kp = M.els[0].length;
	      inverse_elements = [];
	      ni += 1;
	      while (--ni) {
	        i = ni - 1;
	        els = [];
	        np = kp;
	        inverse_elements[i] = [];
	        divisor = M.els[i][i];
	        np += 1;
	        while (--np) {
	          p = kp - np;
	          new_element = M.els[i][p] / divisor;
	          els.push(new_element);
	          if (p >= ki) {
	            inverse_elements[i].push(new_element);
	          }
	        }
	        M.els[i] = els;
	        for (j = _i = 0; 0 <= i ? _i < i : _i > i; j = 0 <= i ? ++_i : --_i) {
	          els = [];
	          np = kp;
	          np += 1;
	          while (--np) {
	            p = kp - np;
	            els.push(M.els[j][p] - M.els[i][p] * M.els[j][i]);
	          }
	          M.els[j] = els;
	        }
	      }
	      return new Matrix(inverse_elements);
	    };

	    Matrix.I = function (n) {
	      var els, i, j, k, nj;
	      els = [];
	      k = n;
	      n += 1;
	      while (--n) {
	        i = k - n;
	        els[i] = [];
	        nj = k;
	        nj += 1;
	        while (--nj) {
	          j = k - nj;
	          els[i][j] = i === j ? 1 : 0;
	        }
	      }
	      return new Matrix(els);
	    };

	    Matrix.prototype.decompose = function () {
	      var els, i, inversePerspectiveMatrix, j, k, matrix, pdum3, perspective, perspectiveMatrix, quaternion, result, rightHandSide, rotate, row, rowElement, s, scale, skew, t, translate, transposedInversePerspectiveMatrix, type, typeKey, v, w, x, y, z, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
	      matrix = this;
	      translate = [];
	      scale = [];
	      skew = [];
	      quaternion = [];
	      perspective = [];
	      els = [];
	      for (i = _i = 0; _i <= 3; i = ++_i) {
	        els[i] = [];
	        for (j = _j = 0; _j <= 3; j = ++_j) {
	          els[i][j] = matrix.els[i][j];
	        }
	      }
	      if (els[3][3] === 0) {
	        return false;
	      }
	      for (i = _k = 0; _k <= 3; i = ++_k) {
	        for (j = _l = 0; _l <= 3; j = ++_l) {
	          els[i][j] /= els[3][3];
	        }
	      }
	      perspectiveMatrix = matrix.dup();
	      for (i = _m = 0; _m <= 2; i = ++_m) {
	        perspectiveMatrix.els[i][3] = 0;
	      }
	      perspectiveMatrix.els[3][3] = 1;
	      if (els[0][3] !== 0 || els[1][3] !== 0 || els[2][3] !== 0) {
	        rightHandSide = new Vector(els.slice(0, 4)[3]);
	        inversePerspectiveMatrix = perspectiveMatrix.inverse();
	        transposedInversePerspectiveMatrix = inversePerspectiveMatrix.transpose();
	        perspective = transposedInversePerspectiveMatrix.multiply(rightHandSide).els;
	        for (i = _n = 0; _n <= 2; i = ++_n) {
	          els[i][3] = 0;
	        }
	        els[3][3] = 1;
	      } else {
	        perspective = [0, 0, 0, 1];
	      }
	      for (i = _o = 0; _o <= 2; i = ++_o) {
	        translate[i] = els[3][i];
	        els[3][i] = 0;
	      }
	      row = [];
	      for (i = _p = 0; _p <= 2; i = ++_p) {
	        row[i] = new Vector(els[i].slice(0, 3));
	      }
	      scale[0] = row[0].length();
	      row[0] = row[0].normalize();
	      skew[0] = row[0].dot(row[1]);
	      row[1] = row[1].combine(row[0], 1.0, -skew[0]);
	      scale[1] = row[1].length();
	      row[1] = row[1].normalize();
	      skew[0] /= scale[1];
	      skew[1] = row[0].dot(row[2]);
	      row[2] = row[2].combine(row[0], 1.0, -skew[1]);
	      skew[2] = row[1].dot(row[2]);
	      row[2] = row[2].combine(row[1], 1.0, -skew[2]);
	      scale[2] = row[2].length();
	      row[2] = row[2].normalize();
	      skew[1] /= scale[2];
	      skew[2] /= scale[2];
	      pdum3 = row[1].cross(row[2]);
	      if (row[0].dot(pdum3) < 0) {
	        for (i = _q = 0; _q <= 2; i = ++_q) {
	          scale[i] *= -1;
	          for (j = _r = 0; _r <= 2; j = ++_r) {
	            row[i].els[j] *= -1;
	          }
	        }
	      }
	      rowElement = function rowElement(index, elementIndex) {
	        return row[index].els[elementIndex];
	      };
	      rotate = [];
	      rotate[1] = Math.asin(-rowElement(0, 2));
	      if (Math.cos(rotate[1]) !== 0) {
	        rotate[0] = Math.atan2(rowElement(1, 2), rowElement(2, 2));
	        rotate[2] = Math.atan2(rowElement(0, 1), rowElement(0, 0));
	      } else {
	        rotate[0] = Math.atan2(-rowElement(2, 0), rowElement(1, 1));
	        rotate[1] = 0;
	      }
	      t = rowElement(0, 0) + rowElement(1, 1) + rowElement(2, 2) + 1.0;
	      if (t > 1e-4) {
	        s = 0.5 / Math.sqrt(t);
	        w = 0.25 / s;
	        x = (rowElement(2, 1) - rowElement(1, 2)) * s;
	        y = (rowElement(0, 2) - rowElement(2, 0)) * s;
	        z = (rowElement(1, 0) - rowElement(0, 1)) * s;
	      } else if (rowElement(0, 0) > rowElement(1, 1) && rowElement(0, 0) > rowElement(2, 2)) {
	        s = Math.sqrt(1.0 + rowElement(0, 0) - rowElement(1, 1) - rowElement(2, 2)) * 2.0;
	        x = 0.25 * s;
	        y = (rowElement(0, 1) + rowElement(1, 0)) / s;
	        z = (rowElement(0, 2) + rowElement(2, 0)) / s;
	        w = (rowElement(2, 1) - rowElement(1, 2)) / s;
	      } else if (rowElement(1, 1) > rowElement(2, 2)) {
	        s = Math.sqrt(1.0 + rowElement(1, 1) - rowElement(0, 0) - rowElement(2, 2)) * 2.0;
	        x = (rowElement(0, 1) + rowElement(1, 0)) / s;
	        y = 0.25 * s;
	        z = (rowElement(1, 2) + rowElement(2, 1)) / s;
	        w = (rowElement(0, 2) - rowElement(2, 0)) / s;
	      } else {
	        s = Math.sqrt(1.0 + rowElement(2, 2) - rowElement(0, 0) - rowElement(1, 1)) * 2.0;
	        x = (rowElement(0, 2) + rowElement(2, 0)) / s;
	        y = (rowElement(1, 2) + rowElement(2, 1)) / s;
	        z = 0.25 * s;
	        w = (rowElement(1, 0) - rowElement(0, 1)) / s;
	      }
	      quaternion = [x, y, z, w];
	      result = new DecomposedMatrix();
	      result.translate = translate;
	      result.scale = scale;
	      result.skew = skew;
	      result.quaternion = quaternion;
	      result.perspective = perspective;
	      result.rotate = rotate;
	      for (typeKey in result) {
	        type = result[typeKey];
	        for (k in type) {
	          v = type[k];
	          if (isNaN(v)) {
	            type[k] = 0;
	          }
	        }
	      }
	      return result;
	    };

	    Matrix.prototype.toString = function () {
	      var i, j, str, _i, _j;
	      str = 'matrix3d(';
	      for (i = _i = 0; _i <= 3; i = ++_i) {
	        for (j = _j = 0; _j <= 3; j = ++_j) {
	          str += roundf(this.els[i][j], 10);
	          if (!(i === 3 && j === 3)) {
	            str += ',';
	          }
	        }
	      }
	      str += ')';
	      return str;
	    };

	    Matrix.matrixForTransform = cacheFn(function (transform) {
	      var matrixEl, result, style, _ref, _ref1, _ref2;
	      matrixEl = document.createElement('div');
	      matrixEl.style.position = 'absolute';
	      matrixEl.style.visibility = 'hidden';
	      matrixEl.style[propertyWithPrefix("transform")] = transform;
	      document.body.appendChild(matrixEl);
	      style = window.getComputedStyle(matrixEl, null);
	      result = (_ref = (_ref1 = style.transform) != null ? _ref1 : style[propertyWithPrefix("transform")]) != null ? _ref : (_ref2 = dynamics.tests) != null ? _ref2.matrixForTransform(transform) : void 0;
	      document.body.removeChild(matrixEl);
	      return result;
	    });

	    Matrix.fromTransform = function (transform) {
	      var digits, elements, i, match, matrixElements, _i;
	      match = transform != null ? transform.match(/matrix3?d?\(([-0-9,e \.]*)\)/) : void 0;
	      if (match) {
	        digits = match[1].split(',');
	        digits = digits.map(parseFloat);
	        if (digits.length === 6) {
	          elements = [digits[0], digits[1], 0, 0, digits[2], digits[3], 0, 0, 0, 0, 1, 0, digits[4], digits[5], 0, 1];
	        } else {
	          elements = digits;
	        }
	      } else {
	        elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	      }
	      matrixElements = [];
	      for (i = _i = 0; _i <= 3; i = ++_i) {
	        matrixElements.push(elements.slice(i * 4, i * 4 + 4));
	      }
	      return new Matrix(matrixElements);
	    };

	    return Matrix;
	  }();

	  prefixFor = cacheFn(function (property) {
	    var k, prefix, prop, propArray, propertyName, _i, _j, _len, _len1, _ref;
	    if (document.body.style[property] !== void 0) {
	      return '';
	    }
	    propArray = property.split('-');
	    propertyName = "";
	    for (_i = 0, _len = propArray.length; _i < _len; _i++) {
	      prop = propArray[_i];
	      propertyName += prop.substring(0, 1).toUpperCase() + prop.substring(1);
	    }
	    _ref = ["Webkit", "Moz", "ms"];
	    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
	      prefix = _ref[_j];
	      k = prefix + propertyName;
	      if (document.body.style[k] !== void 0) {
	        return prefix;
	      }
	    }
	    return '';
	  });

	  propertyWithPrefix = cacheFn(function (property) {
	    var prefix;
	    prefix = prefixFor(property);
	    if (prefix === 'Moz') {
	      return "" + prefix + (property.substring(0, 1).toUpperCase() + property.substring(1));
	    }
	    if (prefix !== '') {
	      return "-" + prefix.toLowerCase() + "-" + toDashed(property);
	    }
	    return toDashed(property);
	  });

	  rAF = typeof window !== "undefined" && window !== null ? window.requestAnimationFrame : void 0;

	  animations = [];

	  animationsTimeouts = [];

	  slow = false;

	  slowRatio = 1;

	  if (typeof window !== "undefined" && window !== null) {
	    window.addEventListener('keyup', function (e) {
	      if (e.keyCode === 68 && e.shiftKey && e.ctrlKey) {
	        return dynamics.toggleSlow();
	      }
	    });
	  }

	  if (rAF == null) {
	    lastTime = 0;
	    rAF = function rAF(callback) {
	      var currTime, id, timeToCall;
	      currTime = Date.now();
	      timeToCall = Math.max(0, 16 - (currTime - lastTime));
	      id = window.setTimeout(function () {
	        return callback(currTime + timeToCall);
	      }, timeToCall);
	      lastTime = currTime + timeToCall;
	      return id;
	    };
	  }

	  runLoopRunning = false;

	  runLoopPaused = false;

	  startRunLoop = function startRunLoop() {
	    if (!runLoopRunning) {
	      runLoopRunning = true;
	      return rAF(_runLoopTick);
	    }
	  };

	  _runLoopTick = function runLoopTick(t) {
	    var animation, toRemoveAnimations, _i, _len;
	    if (runLoopPaused) {
	      rAF(_runLoopTick);
	      return;
	    }
	    toRemoveAnimations = [];
	    for (_i = 0, _len = animations.length; _i < _len; _i++) {
	      animation = animations[_i];
	      if (!animationTick(t, animation)) {
	        toRemoveAnimations.push(animation);
	      }
	    }
	    animations = animations.filter(function (animation) {
	      return toRemoveAnimations.indexOf(animation) === -1;
	    });
	    if (animations.length === 0) {
	      return runLoopRunning = false;
	    } else {
	      return rAF(_runLoopTick);
	    }
	  };

	  animationTick = function animationTick(t, animation) {
	    var key, properties, property, tt, y, _base, _base1, _ref;
	    if (animation.tStart == null) {
	      animation.tStart = t;
	    }
	    tt = (t - animation.tStart) / animation.options.duration;
	    y = animation.curve(tt);
	    properties = {};
	    if (tt >= 1) {
	      if (animation.curve.returnsToSelf) {
	        properties = animation.properties.start;
	      } else {
	        properties = animation.properties.end;
	      }
	    } else {
	      _ref = animation.properties.start;
	      for (key in _ref) {
	        property = _ref[key];
	        properties[key] = interpolate(property, animation.properties.end[key], y);
	      }
	    }
	    applyFrame(animation.el, properties);
	    if (typeof (_base = animation.options).change === "function") {
	      _base.change(animation.el);
	    }
	    if (tt >= 1) {
	      if (typeof (_base1 = animation.options).complete === "function") {
	        _base1.complete(animation.el);
	      }
	    }
	    return tt < 1;
	  };

	  interpolate = function interpolate(start, end, y) {
	    if (start != null && start.interpolate != null) {
	      return start.interpolate(end, y);
	    }
	    return null;
	  };

	  startAnimation = function startAnimation(el, properties, options, timeoutId) {
	    var endProperties, interpolable, isSVG, k, matrix, startProperties, transforms, v;
	    if (timeoutId != null) {
	      animationsTimeouts = animationsTimeouts.filter(function (timeout) {
	        return timeout.id !== timeoutId;
	      });
	    }
	    dynamics.stop(el, {
	      timeout: false
	    });
	    if (!options.animated) {
	      dynamics.css(el, properties);
	      if (typeof options.complete === "function") {
	        options.complete(this);
	      }
	      return;
	    }
	    properties = parseProperties(properties);
	    startProperties = getCurrentProperties(el, Object.keys(properties));
	    endProperties = {};
	    transforms = [];
	    for (k in properties) {
	      v = properties[k];
	      if (el.style != null && transformProperties.contains(k)) {
	        transforms.push([k, v]);
	      } else {
	        interpolable = createInterpolable(v);
	        if (interpolable instanceof InterpolableNumber && el.style != null) {
	          interpolable = new InterpolableString([interpolable, unitForProperty(k, 0)]);
	        }
	        endProperties[k] = interpolable;
	      }
	    }
	    if (transforms.length > 0) {
	      isSVG = isSVGElement(el);
	      if (isSVG) {
	        matrix = new Matrix2D();
	        matrix.applyProperties(transforms);
	      } else {
	        v = transforms.map(function (transform) {
	          return transformValueForProperty(transform[0], transform[1]);
	        }).join(" ");
	        matrix = Matrix.fromTransform(Matrix.matrixForTransform(v));
	      }
	      endProperties['transform'] = matrix.decompose();
	      if (isSVG) {
	        startProperties.transform.applyRotateCenter([endProperties.transform.props.rotate[1], endProperties.transform.props.rotate[2]]);
	      }
	    }
	    animations.push({
	      el: el,
	      properties: {
	        start: startProperties,
	        end: endProperties
	      },
	      options: options,
	      curve: options.type.call(options.type, options)
	    });
	    return startRunLoop();
	  };

	  timeouts = [];

	  timeoutLastId = 0;

	  setRealTimeout = function setRealTimeout(timeout) {
	    if (!isDocumentVisible()) {
	      return;
	    }
	    return timeout.realTimeoutId = setTimeout(function () {
	      timeout.fn();
	      return cancelTimeout(timeout.id);
	    }, timeout.delay);
	  };

	  addTimeout = function addTimeout(fn, delay) {
	    var timeout;
	    timeoutLastId += 1;
	    timeout = {
	      id: timeoutLastId,
	      tStart: Date.now(),
	      fn: fn,
	      delay: delay,
	      originalDelay: delay
	    };
	    setRealTimeout(timeout);
	    timeouts.push(timeout);
	    return timeoutLastId;
	  };

	  cancelTimeout = function cancelTimeout(id) {
	    return timeouts = timeouts.filter(function (timeout) {
	      if (timeout.id === id) {
	        clearTimeout(timeout.realTimeoutId);
	      }
	      return timeout.id !== id;
	    });
	  };

	  leftDelayForTimeout = function leftDelayForTimeout(time, timeout) {
	    var consumedDelay;
	    if (time != null) {
	      consumedDelay = time - timeout.tStart;
	      return timeout.originalDelay - consumedDelay;
	    } else {
	      return timeout.originalDelay;
	    }
	  };

	  if (typeof window !== "undefined" && window !== null) {
	    window.addEventListener('unload', function () {});
	  }

	  timeBeforeVisibilityChange = null;

	  observeVisibilityChange(function (visible) {
	    var animation, difference, timeout, _i, _j, _k, _len, _len1, _len2, _results;
	    runLoopPaused = !visible;
	    if (!visible) {
	      timeBeforeVisibilityChange = Date.now();
	      _results = [];
	      for (_i = 0, _len = timeouts.length; _i < _len; _i++) {
	        timeout = timeouts[_i];
	        _results.push(clearTimeout(timeout.realTimeoutId));
	      }
	      return _results;
	    } else {
	      if (runLoopRunning) {
	        difference = Date.now() - timeBeforeVisibilityChange;
	        for (_j = 0, _len1 = animations.length; _j < _len1; _j++) {
	          animation = animations[_j];
	          if (animation.tStart != null) {
	            animation.tStart += difference;
	          }
	        }
	      }
	      for (_k = 0, _len2 = timeouts.length; _k < _len2; _k++) {
	        timeout = timeouts[_k];
	        timeout.delay = leftDelayForTimeout(timeBeforeVisibilityChange, timeout);
	        setRealTimeout(timeout);
	      }
	      return timeBeforeVisibilityChange = null;
	    }
	  });

	  dynamics = {};

	  dynamics.linear = function () {
	    return function (t) {
	      return t;
	    };
	  };

	  dynamics.spring = function (options) {
	    var A1, A2, decal, frequency, friction, s;
	    if (options == null) {
	      options = {};
	    }
	    applyDefaults(options, dynamics.spring.defaults);
	    frequency = Math.max(1, options.frequency / 20);
	    friction = Math.pow(20, options.friction / 100);
	    s = options.anticipationSize / 1000;
	    decal = Math.max(0, s);
	    A1 = function A1(t) {
	      var M, a, b, x0, x1;
	      M = 0.8;
	      x0 = s / (1 - s);
	      x1 = 0;
	      b = (x0 - M * x1) / (x0 - x1);
	      a = (M - b) / x0;
	      return a * t * options.anticipationStrength / 100 + b;
	    };
	    A2 = function A2(t) {
	      return Math.pow(friction / 10, -t) * (1 - t);
	    };
	    return function (t) {
	      var A, At, a, angle, b, frictionT, y0, yS;
	      frictionT = t / (1 - s) - s / (1 - s);
	      if (t < s) {
	        yS = s / (1 - s) - s / (1 - s);
	        y0 = 0 / (1 - s) - s / (1 - s);
	        b = Math.acos(1 / A1(yS));
	        a = (Math.acos(1 / A1(y0)) - b) / (frequency * -s);
	        A = A1;
	      } else {
	        A = A2;
	        b = 0;
	        a = 1;
	      }
	      At = A(frictionT);
	      angle = frequency * (t - s) * a + b;
	      return 1 - At * Math.cos(angle);
	    };
	  };

	  dynamics.bounce = function (options) {
	    var A, fn, frequency, friction;
	    if (options == null) {
	      options = {};
	    }
	    applyDefaults(options, dynamics.bounce.defaults);
	    frequency = Math.max(1, options.frequency / 20);
	    friction = Math.pow(20, options.friction / 100);
	    A = function A(t) {
	      return Math.pow(friction / 10, -t) * (1 - t);
	    };
	    fn = function fn(t) {
	      var At, a, angle, b;
	      b = -3.14 / 2;
	      a = 1;
	      At = A(t);
	      angle = frequency * t * a + b;
	      return At * Math.cos(angle);
	    };
	    fn.returnsToSelf = true;
	    return fn;
	  };

	  dynamics.gravity = function (options) {
	    var L, bounciness, curves, elasticity, fn, getPointInCurve, gravity;
	    if (options == null) {
	      options = {};
	    }
	    applyDefaults(options, dynamics.gravity.defaults);
	    bounciness = Math.min(options.bounciness / 1250, 0.8);
	    elasticity = options.elasticity / 1000;
	    gravity = 100;
	    curves = [];
	    L = function () {
	      var b, curve;
	      b = Math.sqrt(2 / gravity);
	      curve = {
	        a: -b,
	        b: b,
	        H: 1
	      };
	      if (options.returnsToSelf) {
	        curve.a = 0;
	        curve.b = curve.b * 2;
	      }
	      while (curve.H > 0.001) {
	        L = curve.b - curve.a;
	        curve = {
	          a: curve.b,
	          b: curve.b + L * bounciness,
	          H: curve.H * bounciness * bounciness
	        };
	      }
	      return curve.b;
	    }();
	    getPointInCurve = function getPointInCurve(a, b, H, t) {
	      var c, t2;
	      L = b - a;
	      t2 = 2 / L * t - 1 - a * 2 / L;
	      c = t2 * t2 * H - H + 1;
	      if (options.returnsToSelf) {
	        c = 1 - c;
	      }
	      return c;
	    };
	    (function () {
	      var L2, b, curve, _results;
	      b = Math.sqrt(2 / (gravity * L * L));
	      curve = {
	        a: -b,
	        b: b,
	        H: 1
	      };
	      if (options.returnsToSelf) {
	        curve.a = 0;
	        curve.b = curve.b * 2;
	      }
	      curves.push(curve);
	      L2 = L;
	      _results = [];
	      while (curve.b < 1 && curve.H > 0.001) {
	        L2 = curve.b - curve.a;
	        curve = {
	          a: curve.b,
	          b: curve.b + L2 * bounciness,
	          H: curve.H * elasticity
	        };
	        _results.push(curves.push(curve));
	      }
	      return _results;
	    })();
	    fn = function fn(t) {
	      var curve, i, v;
	      i = 0;
	      curve = curves[i];
	      while (!(t >= curve.a && t <= curve.b)) {
	        i += 1;
	        curve = curves[i];
	        if (!curve) {
	          break;
	        }
	      }
	      if (!curve) {
	        v = options.returnsToSelf ? 0 : 1;
	      } else {
	        v = getPointInCurve(curve.a, curve.b, curve.H, t);
	      }
	      return v;
	    };
	    fn.returnsToSelf = options.returnsToSelf;
	    return fn;
	  };

	  dynamics.forceWithGravity = function (options) {
	    if (options == null) {
	      options = {};
	    }
	    applyDefaults(options, dynamics.forceWithGravity.defaults);
	    options.returnsToSelf = true;
	    return dynamics.gravity(options);
	  };

	  dynamics.bezier = function () {
	    var Bezier, Bezier_, yForX;
	    Bezier_ = function Bezier_(t, p0, p1, p2, p3) {
	      return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;
	    };
	    Bezier = function Bezier(t, p0, p1, p2, p3) {
	      return {
	        x: Bezier_(t, p0.x, p1.x, p2.x, p3.x),
	        y: Bezier_(t, p0.y, p1.y, p2.y, p3.y)
	      };
	    };
	    yForX = function yForX(xTarget, Bs, returnsToSelf) {
	      var B, aB, i, lower, percent, upper, x, xTolerance, _i, _len;
	      B = null;
	      for (_i = 0, _len = Bs.length; _i < _len; _i++) {
	        aB = Bs[_i];
	        if (xTarget >= aB(0).x && xTarget <= aB(1).x) {
	          B = aB;
	        }
	        if (B !== null) {
	          break;
	        }
	      }
	      if (!B) {
	        if (returnsToSelf) {
	          return 0;
	        } else {
	          return 1;
	        }
	      }
	      xTolerance = 0.0001;
	      lower = 0;
	      upper = 1;
	      percent = (upper + lower) / 2;
	      x = B(percent).x;
	      i = 0;
	      while (Math.abs(xTarget - x) > xTolerance && i < 100) {
	        if (xTarget > x) {
	          lower = percent;
	        } else {
	          upper = percent;
	        }
	        percent = (upper + lower) / 2;
	        x = B(percent).x;
	        i += 1;
	      }
	      return B(percent).y;
	    };
	    return function (options) {
	      var Bs, fn, points;
	      if (options == null) {
	        options = {};
	      }
	      points = options.points;
	      Bs = function () {
	        var i, k, _fn;
	        Bs = [];
	        _fn = function _fn(pointA, pointB) {
	          var B2;
	          B2 = function B2(t) {
	            return Bezier(t, pointA, pointA.cp[pointA.cp.length - 1], pointB.cp[0], pointB);
	          };
	          return Bs.push(B2);
	        };
	        for (i in points) {
	          k = parseInt(i);
	          if (k >= points.length - 1) {
	            break;
	          }
	          _fn(points[k], points[k + 1]);
	        }
	        return Bs;
	      }();
	      fn = function fn(t) {
	        if (t === 0) {
	          return 0;
	        } else if (t === 1) {
	          return 1;
	        } else {
	          return yForX(t, Bs, this.returnsToSelf);
	        }
	      };
	      fn.returnsToSelf = points[points.length - 1].y === 0;
	      return fn;
	    };
	  }();

	  dynamics.easeInOut = function (options) {
	    var friction, _ref;
	    if (options == null) {
	      options = {};
	    }
	    friction = (_ref = options.friction) != null ? _ref : dynamics.easeInOut.defaults.friction;
	    return dynamics.bezier({
	      points: [{
	        x: 0,
	        y: 0,
	        cp: [{
	          x: 0.92 - friction / 1000,
	          y: 0
	        }]
	      }, {
	        x: 1,
	        y: 1,
	        cp: [{
	          x: 0.08 + friction / 1000,
	          y: 1
	        }]
	      }]
	    });
	  };

	  dynamics.easeIn = function (options) {
	    var friction, _ref;
	    if (options == null) {
	      options = {};
	    }
	    friction = (_ref = options.friction) != null ? _ref : dynamics.easeIn.defaults.friction;
	    return dynamics.bezier({
	      points: [{
	        x: 0,
	        y: 0,
	        cp: [{
	          x: 0.92 - friction / 1000,
	          y: 0
	        }]
	      }, {
	        x: 1,
	        y: 1,
	        cp: [{
	          x: 1,
	          y: 1
	        }]
	      }]
	    });
	  };

	  dynamics.easeOut = function (options) {
	    var friction, _ref;
	    if (options == null) {
	      options = {};
	    }
	    friction = (_ref = options.friction) != null ? _ref : dynamics.easeOut.defaults.friction;
	    return dynamics.bezier({
	      points: [{
	        x: 0,
	        y: 0,
	        cp: [{
	          x: 0,
	          y: 0
	        }]
	      }, {
	        x: 1,
	        y: 1,
	        cp: [{
	          x: 0.08 + friction / 1000,
	          y: 1
	        }]
	      }]
	    });
	  };

	  dynamics.spring.defaults = {
	    frequency: 300,
	    friction: 200,
	    anticipationSize: 0,
	    anticipationStrength: 0
	  };

	  dynamics.bounce.defaults = {
	    frequency: 300,
	    friction: 200
	  };

	  dynamics.forceWithGravity.defaults = dynamics.gravity.defaults = {
	    bounciness: 400,
	    elasticity: 200
	  };

	  dynamics.easeInOut.defaults = dynamics.easeIn.defaults = dynamics.easeOut.defaults = {
	    friction: 500
	  };

	  dynamics.css = makeArrayFn(function (el, properties) {
	    return applyProperties(el, properties, true);
	  });

	  dynamics.animate = makeArrayFn(function (el, properties, options) {
	    var id;
	    if (options == null) {
	      options = {};
	    }
	    options = clone(options);
	    applyDefaults(options, {
	      type: dynamics.easeInOut,
	      duration: 1000,
	      delay: 0,
	      animated: true
	    });
	    options.duration = Math.max(0, options.duration * slowRatio);
	    options.delay = Math.max(0, options.delay);
	    if (options.delay === 0) {
	      return startAnimation(el, properties, options);
	    } else {
	      id = dynamics.setTimeout(function () {
	        return startAnimation(el, properties, options, id);
	      }, options.delay);
	      return animationsTimeouts.push({
	        id: id,
	        el: el
	      });
	    }
	  });

	  dynamics.stop = makeArrayFn(function (el, options) {
	    if (options == null) {
	      options = {};
	    }
	    if (options.timeout == null) {
	      options.timeout = true;
	    }
	    if (options.timeout) {
	      animationsTimeouts = animationsTimeouts.filter(function (timeout) {
	        if (timeout.el === el && (options.filter == null || options.filter(timeout))) {
	          dynamics.clearTimeout(timeout.id);
	          return false;
	        }
	        return true;
	      });
	    }
	    return animations = animations.filter(function (animation) {
	      return animation.el !== el;
	    });
	  });

	  dynamics.setTimeout = function (fn, delay) {
	    return addTimeout(fn, delay * slowRatio);
	  };

	  dynamics.clearTimeout = function (id) {
	    return cancelTimeout(id);
	  };

	  dynamics.toggleSlow = function () {
	    slow = !slow;
	    if (slow) {
	      slowRatio = 3;
	    } else {
	      slowRatio = 1;
	    }
	    return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log("dynamics.js: slow animations " + (slow ? "enabled" : "disabled")) : void 0 : void 0;
	  };

	  if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
	    module.exports = dynamics;
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return dynamics;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    window.dynamics = dynamics;
	  }
		}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA2Zjk4ZTNhZjE3MTg3OGI1MTgyNCIsIndlYnBhY2s6Ly8vYXBwL3NyYy9zY3JpcHRzL21haW4uanMiLCJ3ZWJwYWNrOi8vL2FwcC9zcmMvc2NyaXB0cy9pbnRyby1hbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vL2FwcC9wdWJsaWMvYm93ZXJfY29tcG9uZW50cy9keW5hbWljcy5qcy9saWIvZHluYW1pY3MuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNmY5OGUzYWYxNzE4NzhiNTE4MjRcbiAqKi8iLCJpbXBvcnQgaW50cm9BbmltYXRpb24gZnJvbSAnLi9pbnRyby1hbmltYXRpb24nO1xuaW50cm9BbmltYXRpb24uaW5pdCgpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYXBwL3NyYy9zY3JpcHRzL21haW4uanNcbiAqKi8iLCJpbXBvcnQgZHluYW1pY3MgZnJvbSAnZHluYW1pY3MuanMnO1xuXG5jb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuY29uc3QgbG9nbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWpzLWxvZ29dJyk7XG5jb25zdCB0aXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWpzLXRpdGxlXScpO1xuY29uc3QgdHdpdHRlckxpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1qcy10d2l0dGVyXScpO1xuY29uc3QgZ2l0aHViTG9nbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWpzLWdpdGh1Yi1sb2dvXSBzdmcnKTtcblxuZHluYW1pY3MuY3NzKGJvZHksIHsgc2NhbGU6IDEuMSB9KTtcbmR5bmFtaWNzLmNzcyhsb2dvLCB7IG9wYWNpdHk6IDAsIHRyYW5zbGF0ZVk6IDE1IH0pO1xuZHluYW1pY3MuY3NzKHRpdGxlLCB7IG9wYWNpdHk6IDAsIHRyYW5zbGF0ZVk6IC0xNSB9KTtcbmR5bmFtaWNzLmNzcyhnaXRodWJMb2dvLCB7IG9wYWNpdHk6IDAsIHRyYW5zbGF0ZVk6IC0xNSB9KTtcbmR5bmFtaWNzLmNzcyh0d2l0dGVyTGluaywgeyBvcGFjaXR5OiAwIH0pO1xuXG5mdW5jdGlvbiBhbmltYXRlQ29udGVudCgpIHtcbiAgLy8gTG9nb1xuICBkeW5hbWljcy5hbmltYXRlKGxvZ28sIHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zbGF0ZVk6IDAsXG4gIH0sIHtcbiAgICBkZWxheTogNTAsXG4gICAgdHlwZTogZHluYW1pY3Muc3ByaW5nLFxuICB9KTtcblxuICAvLyBQYXJhZ3JhcGhcbiAgZHluYW1pY3MuYW5pbWF0ZSh0aXRsZSwge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNsYXRlWTogMCxcbiAgfSwge1xuICAgIGRlbGF5OiA1MCxcbiAgICB0eXBlOiBkeW5hbWljcy5zcHJpbmcsXG4gIH0pO1xuXG4gIC8vIEdpdGh1YiBsb2dvXG4gIGR5bmFtaWNzLmFuaW1hdGUoZ2l0aHViTG9nbywge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNsYXRlWTogMCxcbiAgfSwge1xuICAgIGRlbGF5OiA3NTAsXG4gICAgdHlwZTogZHluYW1pY3Muc3ByaW5nLFxuICAgIGZyZXF1ZW5jeTogMTQwLFxuICAgIGZyaWN0aW9uOiAyMjAsXG4gIH0pO1xuXG4gIC8vIFR3aXR0ZXIgbGlua1xuICBkeW5hbWljcy5hbmltYXRlKHR3aXR0ZXJMaW5rLCB7XG4gICAgb3BhY2l0eTogMSxcbiAgfSwge1xuICAgIGRlbGF5OiA3NTAsXG4gICAgdHlwZTogZHluYW1pY3MuZWFzZUluLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZUJvZHkoKSB7XG4gIC8vIEJvZHlcbiAgZHluYW1pY3MuYW5pbWF0ZShib2R5LCB7XG4gICAgb3BhY2l0eTogMSxcbiAgICBzY2FsZTogMSxcbiAgfSwge1xuICAgIGR1cmF0aW9uOiAxNTAwLFxuICAgIHR5cGU6IGR5bmFtaWNzLmVhc2VJbk91dCxcbiAgICBjb21wbGV0ZTogYW5pbWF0ZUNvbnRlbnQsXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGFuaW1hdGVCb2R5LFxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGFwcC9zcmMvc2NyaXB0cy9pbnRyby1hbmltYXRpb24uanNcbiAqKi8iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBDb2xvciwgRGVjb21wb3NlZE1hdHJpeCwgRGVjb21wb3NlZE1hdHJpeDJELCBJbnRlcnBvbGFibGVBcnJheSwgSW50ZXJwb2xhYmxlQ29sb3IsIEludGVycG9sYWJsZU51bWJlciwgSW50ZXJwb2xhYmxlT2JqZWN0LCBJbnRlcnBvbGFibGVTdHJpbmcsIE1hdHJpeCwgTWF0cml4MkQsIFNldCwgVmVjdG9yLCBhZGRUaW1lb3V0LCBhbmltYXRpb25UaWNrLCBhbmltYXRpb25zLCBhbmltYXRpb25zVGltZW91dHMsIGFwcGx5RGVmYXVsdHMsIGFwcGx5RnJhbWUsIGFwcGx5UHJvcGVydGllcywgYmFzZVNWRywgY2FjaGVGbiwgY2FuY2VsVGltZW91dCwgY2xvbmUsIGNyZWF0ZUludGVycG9sYWJsZSwgZGVmYXVsdFZhbHVlRm9yS2V5LCBkZWdQcm9wZXJ0aWVzLCBkeW5hbWljcywgZ2V0Q3VycmVudFByb3BlcnRpZXMsIGludGVycG9sYXRlLCBpc0RvY3VtZW50VmlzaWJsZSwgaXNTVkdFbGVtZW50LCBsYXN0VGltZSwgbGVmdERlbGF5Rm9yVGltZW91dCwgbWFrZUFycmF5Rm4sIG9ic2VydmVWaXNpYmlsaXR5Q2hhbmdlLCBwYXJzZVByb3BlcnRpZXMsIHByZWZpeEZvciwgcHJvcGVydHlXaXRoUHJlZml4LCBweFByb3BlcnRpZXMsIHJBRiwgcm91bmRmLCBydW5Mb29wUGF1c2VkLCBydW5Mb29wUnVubmluZywgcnVuTG9vcFRpY2ssIHNldFJlYWxUaW1lb3V0LCBzbG93LCBzbG93UmF0aW8sIHN0YXJ0QW5pbWF0aW9uLCBzdGFydFJ1bkxvb3AsIHN2Z1Byb3BlcnRpZXMsIHRpbWVCZWZvcmVWaXNpYmlsaXR5Q2hhbmdlLCB0aW1lb3V0TGFzdElkLCB0aW1lb3V0cywgdG9EYXNoZWQsIHRyYW5zZm9ybVByb3BlcnRpZXMsIHRyYW5zZm9ybVZhbHVlRm9yUHJvcGVydHksIHVuaXRGb3JQcm9wZXJ0eSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIGlzRG9jdW1lbnRWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgfHwgKGR5bmFtaWNzLnRlc3RzICE9IG51bGwpO1xuICB9O1xuXG4gIG9ic2VydmVWaXNpYmlsaXR5Q2hhbmdlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBmbnM7XG4gICAgZm5zID0gW107XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmbiwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGZucy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGZuID0gZm5zW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGZuKGlzRG9jdW1lbnRWaXNpYmxlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICByZXR1cm4gZm5zLnB1c2goZm4pO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgY2xvbmUgPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGssIG5ld08sIHY7XG4gICAgbmV3TyA9IHt9O1xuICAgIGZvciAoayBpbiBvKSB7XG4gICAgICB2ID0gb1trXTtcbiAgICAgIG5ld09ba10gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gbmV3TztcbiAgfTtcblxuICBjYWNoZUZuID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBkYXRhO1xuICAgIGRhdGEgPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaywga2V5LCByZXN1bHQsIF9pLCBfbGVuO1xuICAgICAga2V5ID0gXCJcIjtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGsgPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICBrZXkgKz0gay50b1N0cmluZygpICsgXCIsXCI7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkYXRhW2tleV0gPSByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgbWFrZUFycmF5Rm4gPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGFyZ3MsIGksIHJlcztcbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5IHx8IGVsIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZWwgaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbikge1xuICAgICAgICByZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IGVsLmxlbmd0aDsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZWxbaV0pO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmbi5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgYXBwbHlEZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgdmFyIGssIHYsIF9yZXN1bHRzO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChrIGluIGRlZmF1bHRzKSB7XG4gICAgICB2ID0gZGVmYXVsdHNba107XG4gICAgICBfcmVzdWx0cy5wdXNoKG9wdGlvbnNba10gIT0gbnVsbCA/IG9wdGlvbnNba10gOiBvcHRpb25zW2tdID0gdik7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBhcHBseUZyYW1lID0gZnVuY3Rpb24oZWwsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgaywgdiwgX3Jlc3VsdHM7XG4gICAgaWYgKChlbC5zdHlsZSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIGFwcGx5UHJvcGVydGllcyhlbCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGsgaW4gcHJvcGVydGllcykge1xuICAgICAgICB2ID0gcHJvcGVydGllc1trXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChlbFtrXSA9IHYuZm9ybWF0KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH1cbiAgfTtcblxuICBhcHBseVByb3BlcnRpZXMgPSBmdW5jdGlvbihlbCwgcHJvcGVydGllcykge1xuICAgIHZhciBpc1NWRywgaywgbWF0cml4LCB0cmFuc2Zvcm1zLCB2O1xuICAgIHByb3BlcnRpZXMgPSBwYXJzZVByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgdHJhbnNmb3JtcyA9IFtdO1xuICAgIGlzU1ZHID0gaXNTVkdFbGVtZW50KGVsKTtcbiAgICBmb3IgKGsgaW4gcHJvcGVydGllcykge1xuICAgICAgdiA9IHByb3BlcnRpZXNba107XG4gICAgICBpZiAodHJhbnNmb3JtUHJvcGVydGllcy5jb250YWlucyhrKSkge1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goW2ssIHZdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2LmZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgdiA9IHYuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHYgPSBcIlwiICsgdiArICh1bml0Rm9yUHJvcGVydHkoaywgdikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NWRyAmJiBzdmdQcm9wZXJ0aWVzLmNvbnRhaW5zKGspKSB7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLnN0eWxlW3Byb3BlcnR5V2l0aFByZWZpeChrKV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChpc1NWRykge1xuICAgICAgICBtYXRyaXggPSBuZXcgTWF0cml4MkQoKTtcbiAgICAgICAgbWF0cml4LmFwcGx5UHJvcGVydGllcyh0cmFuc2Zvcm1zKTtcbiAgICAgICAgcmV0dXJuIGVsLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBtYXRyaXguZGVjb21wb3NlKCkuZm9ybWF0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9ICh0cmFuc2Zvcm1zLm1hcChmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtVmFsdWVGb3JQcm9wZXJ0eSh0cmFuc2Zvcm1bMF0sIHRyYW5zZm9ybVsxXSk7XG4gICAgICAgIH0pKS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIGVsLnN0eWxlW3Byb3BlcnR5V2l0aFByZWZpeChcInRyYW5zZm9ybVwiKV0gPSB2O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpc1NWR0VsZW1lbnQgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBfcmVmLCBfcmVmMTtcbiAgICBpZiAoKHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIFNWR0VsZW1lbnQgIT09IG51bGwpICYmICh0eXBlb2YgU1ZHU1ZHRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTVkdTVkdFbGVtZW50ICE9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAhKGVsIGluc3RhbmNlb2YgU1ZHU1ZHRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoX3JlZiA9IChfcmVmMSA9IGR5bmFtaWNzLnRlc3RzKSAhPSBudWxsID8gdHlwZW9mIF9yZWYxLmlzU1ZHID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmMS5pc1NWRyhlbCkgOiB2b2lkIDAgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmIDogZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJvdW5kZiA9IGZ1bmN0aW9uKHYsIGRlY2ltYWwpIHtcbiAgICB2YXIgZDtcbiAgICBkID0gTWF0aC5wb3coMTAsIGRlY2ltYWwpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHYgKiBkKSAvIGQ7XG4gIH07XG5cbiAgU2V0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNldChhcnJheSkge1xuICAgICAgdmFyIHYsIF9pLCBfbGVuO1xuICAgICAgdGhpcy5vYmogPSB7fTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXJyYXkubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdiA9IGFycmF5W19pXTtcbiAgICAgICAgdGhpcy5vYmpbdl0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy5vYmpbdl0gPT09IDE7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG5cbiAgfSkoKTtcblxuICB0b0Rhc2hlZCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbigkMSkge1xuICAgICAgcmV0dXJuIFwiLVwiICsgJDEudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICBweFByb3BlcnRpZXMgPSBuZXcgU2V0KCdtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5Cb3R0b20sbWFyZ2luUmlnaHQscGFkZGluZ1RvcCxwYWRkaW5nTGVmdCxwYWRkaW5nQm90dG9tLHBhZGRpbmdSaWdodCx0b3AsbGVmdCxib3R0b20scmlnaHQsdHJhbnNsYXRlWCx0cmFuc2xhdGVZLHRyYW5zbGF0ZVoscGVyc3BlY3RpdmVYLHBlcnNwZWN0aXZlWSxwZXJzcGVjdGl2ZVosd2lkdGgsaGVpZ2h0LG1heFdpZHRoLG1heEhlaWdodCxtaW5XaWR0aCxtaW5IZWlnaHQsYm9yZGVyUmFkaXVzJy5zcGxpdCgnLCcpKTtcblxuICBkZWdQcm9wZXJ0aWVzID0gbmV3IFNldCgncm90YXRlLHJvdGF0ZVgscm90YXRlWSxyb3RhdGVaLHNrZXcsc2tld1gsc2tld1ksc2tld1onLnNwbGl0KCcsJykpO1xuXG4gIHRyYW5zZm9ybVByb3BlcnRpZXMgPSBuZXcgU2V0KCd0cmFuc2xhdGUsdHJhbnNsYXRlWCx0cmFuc2xhdGVZLHRyYW5zbGF0ZVosc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoscm90YXRlLHJvdGF0ZVgscm90YXRlWSxyb3RhdGVaLHJvdGF0ZUMscm90YXRlQ1gscm90YXRlQ1ksc2tldyxza2V3WCxza2V3WSxza2V3WixwZXJzcGVjdGl2ZScuc3BsaXQoJywnKSk7XG5cbiAgc3ZnUHJvcGVydGllcyA9IG5ldyBTZXQoJ2FjY2VudC1oZWlnaHQsYXNjZW50LGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxiYXNlbGluZS1zaGlmdCxiaWFzLGN4LGN5LGQsZGlmZnVzZUNvbnN0YW50LGRpdmlzb3IsZHgsZHksZWxldmF0aW9uLGZpbHRlclJlcyxmeCxmeSxncmFkaWVudFRyYW5zZm9ybSxoZWlnaHQsazEsazIsazMsazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsbGV0dGVyLXNwYWNpbmcsbGltaXRpbmdDb25lQW5nbGUsbWFya2VySGVpZ2h0LG1hcmtlcldpZHRoLG51bU9jdGF2ZXMsb3JkZXIsb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhdGhMZW5ndGgscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHIscmFkaXVzLHJ4LHJ5LHNlZWQsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHN0ZERldmlhdGlvbixzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN1cmZhY2VTY2FsZSx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRyYW5zZm9ybSx1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx2aWV3Qm94LHdpZHRoLHgseDEseDIseSx5MSx5Mix6Jy5zcGxpdCgnLCcpKTtcblxuICB1bml0Rm9yUHJvcGVydHkgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAocHhQcm9wZXJ0aWVzLmNvbnRhaW5zKGspKSB7XG4gICAgICByZXR1cm4gJ3B4JztcbiAgICB9IGVsc2UgaWYgKGRlZ1Byb3BlcnRpZXMuY29udGFpbnMoaykpIHtcbiAgICAgIHJldHVybiAnZGVnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIHRyYW5zZm9ybVZhbHVlRm9yUHJvcGVydHkgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgdmFyIG1hdGNoLCB1bml0O1xuICAgIG1hdGNoID0gKFwiXCIgKyB2KS5tYXRjaCgvXihbMC05Li1dKikoW14wLTldKikkLyk7XG4gICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgIHYgPSBtYXRjaFsxXTtcbiAgICAgIHVuaXQgPSBtYXRjaFsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdiA9IHBhcnNlRmxvYXQodik7XG4gICAgfVxuICAgIHYgPSByb3VuZGYocGFyc2VGbG9hdCh2KSwgMTApO1xuICAgIGlmICgodW5pdCA9PSBudWxsKSB8fCB1bml0ID09PSBcIlwiKSB7XG4gICAgICB1bml0ID0gdW5pdEZvclByb3BlcnR5KGssIHYpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIGsgKyBcIihcIiArIHYgKyB1bml0ICsgXCIpXCI7XG4gIH07XG5cbiAgcGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgIHZhciBheGlzLCBtYXRjaCwgcGFyc2VkLCBwcm9wZXJ0eSwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmO1xuICAgIHBhcnNlZCA9IHt9O1xuICAgIGZvciAocHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wZXJ0aWVzLmNvbnRhaW5zKHByb3BlcnR5KSkge1xuICAgICAgICBtYXRjaCA9IHByb3BlcnR5Lm1hdGNoKC8odHJhbnNsYXRlfHJvdGF0ZUN8cm90YXRlfHNrZXd8c2NhbGV8cGVyc3BlY3RpdmUpKFh8WXxafCkvKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzJdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJzZWRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3JlZiA9IFsnWCcsICdZJywgJ1onXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGF4aXMgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIHBhcnNlZFttYXRjaFsxXSArIGF4aXNdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgZGVmYXVsdFZhbHVlRm9yS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHY7XG4gICAgdiA9IGtleSA9PT0gJ29wYWNpdHknID8gMSA6IDA7XG4gICAgcmV0dXJuIFwiXCIgKyB2ICsgKHVuaXRGb3JQcm9wZXJ0eShrZXksIHYpKTtcbiAgfTtcblxuICBnZXRDdXJyZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uKGVsLCBrZXlzKSB7XG4gICAgdmFyIGlzU1ZHLCBrZXksIG1hdHJpeCwgcHJvcGVydGllcywgc3R5bGUsIHYsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWY7XG4gICAgcHJvcGVydGllcyA9IHt9O1xuICAgIGlzU1ZHID0gaXNTVkdFbGVtZW50KGVsKTtcbiAgICBpZiAoZWwuc3R5bGUgIT0gbnVsbCkge1xuICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGtleXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tfaV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wZXJ0aWVzLmNvbnRhaW5zKGtleSkpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1sndHJhbnNmb3JtJ10gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgyRCgoX3JlZiA9IGVsLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpICE9IG51bGwgPyBfcmVmLm1hdHJpeCA6IHZvaWQgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXggPSBNYXRyaXguZnJvbVRyYW5zZm9ybShzdHlsZVtwcm9wZXJ0eVdpdGhQcmVmaXgoJ3RyYW5zZm9ybScpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzWyd0cmFuc2Zvcm0nXSA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IHN0eWxlW2tleV07XG4gICAgICAgICAgaWYgKCh2ID09IG51bGwpICYmIHN2Z1Byb3BlcnRpZXMuY29udGFpbnMoa2V5KSkge1xuICAgICAgICAgICAgdiA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiA9PT0gXCJcIiB8fCAodiA9PSBudWxsKSkge1xuICAgICAgICAgICAgdiA9IGRlZmF1bHRWYWx1ZUZvcktleShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSBjcmVhdGVJbnRlcnBvbGFibGUodik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0ga2V5cy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tfal07XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IGNyZWF0ZUludGVycG9sYWJsZShlbFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH07XG5cbiAgY3JlYXRlSW50ZXJwb2xhYmxlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaW50ZXJwb2xhYmxlLCBrbGFzcywga2xhc3NlcywgX2ksIF9sZW47XG4gICAga2xhc3NlcyA9IFtJbnRlcnBvbGFibGVBcnJheSwgSW50ZXJwb2xhYmxlT2JqZWN0LCBJbnRlcnBvbGFibGVOdW1iZXIsIEludGVycG9sYWJsZVN0cmluZ107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBrbGFzc2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBrbGFzcyA9IGtsYXNzZXNbX2ldO1xuICAgICAgaW50ZXJwb2xhYmxlID0ga2xhc3MuY3JlYXRlKHZhbHVlKTtcbiAgICAgIGlmIChpbnRlcnBvbGFibGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBJbnRlcnBvbGFibGVTdHJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhYmxlU3RyaW5nKHBhcnRzKSB7XG4gICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICB0aGlzLmZvcm1hdCA9IF9fYmluZCh0aGlzLmZvcm1hdCwgdGhpcyk7XG4gICAgICB0aGlzLmludGVycG9sYXRlID0gX19iaW5kKHRoaXMuaW50ZXJwb2xhdGUsIHRoaXMpO1xuICAgIH1cblxuICAgIEludGVycG9sYWJsZVN0cmluZy5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihlbmRJbnRlcnBvbGFibGUsIHQpIHtcbiAgICAgIHZhciBlbmQsIGksIG5ld1BhcnRzLCBzdGFydCwgX2ksIF9yZWY7XG4gICAgICBzdGFydCA9IHRoaXMucGFydHM7XG4gICAgICBlbmQgPSBlbmRJbnRlcnBvbGFibGUucGFydHM7XG4gICAgICBuZXdQYXJ0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gTWF0aC5taW4oc3RhcnQubGVuZ3RoLCBlbmQubGVuZ3RoKTsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgaWYgKHN0YXJ0W2ldLmludGVycG9sYXRlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHN0YXJ0W2ldLmludGVycG9sYXRlKGVuZFtpXSwgdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1BhcnRzLnB1c2goc3RhcnRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEludGVycG9sYWJsZVN0cmluZyhuZXdQYXJ0cyk7XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZVN0cmluZy5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFydHM7XG4gICAgICBwYXJ0cyA9IHRoaXMucGFydHMubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsLmZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbC5mb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgSW50ZXJwb2xhYmxlU3RyaW5nLmNyZWF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXgsIG1hdGNoLCBtYXRjaGVzLCBwYXJ0cywgcmUsIHR5cGUsIHR5cGVzLCBfaSwgX2osIF9sZW4sIF9sZW4xO1xuICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICBtYXRjaGVzID0gW107XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHJlOiAvKCNbYS1mXFxkXXszLDZ9KS9pZyxcbiAgICAgICAgICBrbGFzczogSW50ZXJwb2xhYmxlQ29sb3IsXG4gICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHJlOiAvKHJnYmE/XFwoWzAtOS5dKiwgP1swLTkuXSosID9bMC05Ll0qKD86LCA/WzAtOS5dKik/XFwpKS9pZyxcbiAgICAgICAgICBrbGFzczogSW50ZXJwb2xhYmxlQ29sb3IsXG4gICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHJlOiAvKFstK10/W1xcZC5dKykvaWcsXG4gICAgICAgICAga2xhc3M6IEludGVycG9sYWJsZU51bWJlcixcbiAgICAgICAgICBwYXJzZTogcGFyc2VGbG9hdFxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0eXBlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB0eXBlID0gdHlwZXNbX2ldO1xuICAgICAgICByZSA9IHR5cGUucmU7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBtYXRjaC5pbmRleCxcbiAgICAgICAgICAgIGxlbmd0aDogbWF0Y2hbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgaW50ZXJwb2xhYmxlOiB0eXBlLmtsYXNzLmNyZWF0ZSh0eXBlLnBhcnNlKG1hdGNoWzFdKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmluZGV4ID4gYi5pbmRleDtcbiAgICAgIH0pO1xuICAgICAgcGFydHMgPSBbXTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IG1hdGNoZXMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2hlc1tfal07XG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA8IGluZGV4KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlLnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKG1hdGNoLmludGVycG9sYWJsZSk7XG4gICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhYmxlU3RyaW5nKHBhcnRzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEludGVycG9sYWJsZVN0cmluZztcblxuICB9KSgpO1xuXG4gIEludGVycG9sYWJsZU9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJbnRlcnBvbGFibGVPYmplY3Qob2JqKSB7XG4gICAgICB0aGlzLmZvcm1hdCA9IF9fYmluZCh0aGlzLmZvcm1hdCwgdGhpcyk7XG4gICAgICB0aGlzLmludGVycG9sYXRlID0gX19iaW5kKHRoaXMuaW50ZXJwb2xhdGUsIHRoaXMpO1xuICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgfVxuXG4gICAgSW50ZXJwb2xhYmxlT2JqZWN0LnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGVuZEludGVycG9sYWJsZSwgdCkge1xuICAgICAgdmFyIGVuZCwgaywgbmV3T2JqLCBzdGFydCwgdjtcbiAgICAgIHN0YXJ0ID0gdGhpcy5vYmo7XG4gICAgICBlbmQgPSBlbmRJbnRlcnBvbGFibGUub2JqO1xuICAgICAgbmV3T2JqID0ge307XG4gICAgICBmb3IgKGsgaW4gc3RhcnQpIHtcbiAgICAgICAgdiA9IHN0YXJ0W2tdO1xuICAgICAgICBpZiAodi5pbnRlcnBvbGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3T2JqW2tdID0gdi5pbnRlcnBvbGF0ZShlbmRba10sIHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld09ialtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhYmxlT2JqZWN0KG5ld09iaik7XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZU9iamVjdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vYmo7XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGssIG9iaiwgdjtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgIG9ialtrXSA9IGNyZWF0ZUludGVycG9sYWJsZSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYWJsZU9iamVjdChvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBJbnRlcnBvbGFibGVPYmplY3Q7XG5cbiAgfSkoKTtcblxuICBJbnRlcnBvbGFibGVOdW1iZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhYmxlTnVtYmVyKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvcm1hdCA9IF9fYmluZCh0aGlzLmZvcm1hdCwgdGhpcyk7XG4gICAgICB0aGlzLmludGVycG9sYXRlID0gX19iaW5kKHRoaXMuaW50ZXJwb2xhdGUsIHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH1cblxuICAgIEludGVycG9sYWJsZU51bWJlci5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihlbmRJbnRlcnBvbGFibGUsIHQpIHtcbiAgICAgIHZhciBlbmQsIHN0YXJ0O1xuICAgICAgc3RhcnQgPSB0aGlzLnZhbHVlO1xuICAgICAgZW5kID0gZW5kSW50ZXJwb2xhYmxlLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGFibGVOdW1iZXIoKGVuZCAtIHN0YXJ0KSAqIHQgKyBzdGFydCk7XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZU51bWJlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm91bmRmKHRoaXMudmFsdWUsIDUpO1xuICAgIH07XG5cbiAgICBJbnRlcnBvbGFibGVOdW1iZXIuY3JlYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhYmxlTnVtYmVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW50ZXJwb2xhYmxlTnVtYmVyO1xuXG4gIH0pKCk7XG5cbiAgSW50ZXJwb2xhYmxlQXJyYXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhYmxlQXJyYXkodmFsdWVzKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHRoaXMuZm9ybWF0ID0gX19iaW5kKHRoaXMuZm9ybWF0LCB0aGlzKTtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGUgPSBfX2JpbmQodGhpcy5pbnRlcnBvbGF0ZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgSW50ZXJwb2xhYmxlQXJyYXkucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oZW5kSW50ZXJwb2xhYmxlLCB0KSB7XG4gICAgICB2YXIgZW5kLCBpLCBuZXdWYWx1ZXMsIHN0YXJ0LCBfaSwgX3JlZjtcbiAgICAgIHN0YXJ0ID0gdGhpcy52YWx1ZXM7XG4gICAgICBlbmQgPSBlbmRJbnRlcnBvbGFibGUudmFsdWVzO1xuICAgICAgbmV3VmFsdWVzID0gW107XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSBNYXRoLm1pbihzdGFydC5sZW5ndGgsIGVuZC5sZW5ndGgpOyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICBpZiAoc3RhcnRbaV0uaW50ZXJwb2xhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld1ZhbHVlcy5wdXNoKHN0YXJ0W2ldLmludGVycG9sYXRlKGVuZFtpXSwgdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1ZhbHVlcy5wdXNoKHN0YXJ0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGFibGVBcnJheShuZXdWYWx1ZXMpO1xuICAgIH07XG5cbiAgICBJbnRlcnBvbGFibGVBcnJheS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsLmZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbC5mb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgSW50ZXJwb2xhYmxlQXJyYXkuY3JlYXRlRnJvbUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICB2YXIgdmFsdWVzO1xuICAgICAgdmFsdWVzID0gYXJyLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludGVycG9sYWJsZSh2YWwpIHx8IHZhbDtcbiAgICAgIH0pO1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEludGVycG9sYWJsZUFycmF5KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZUFycmF5LmNyZWF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gSW50ZXJwb2xhYmxlQXJyYXkuY3JlYXRlRnJvbUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW50ZXJwb2xhYmxlQXJyYXk7XG5cbiAgfSkoKTtcblxuICBDb2xvciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDb2xvcihyZ2IsIGZvcm1hdCkge1xuICAgICAgdGhpcy5yZ2IgPSByZ2IgIT0gbnVsbCA/IHJnYiA6IHt9O1xuICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICB0aGlzLnRvUmdiYSA9IF9fYmluZCh0aGlzLnRvUmdiYSwgdGhpcyk7XG4gICAgICB0aGlzLnRvUmdiID0gX19iaW5kKHRoaXMudG9SZ2IsIHRoaXMpO1xuICAgICAgdGhpcy50b0hleCA9IF9fYmluZCh0aGlzLnRvSGV4LCB0aGlzKTtcbiAgICB9XG5cbiAgICBDb2xvci5mcm9tSGV4ID0gZnVuY3Rpb24oaGV4KSB7XG4gICAgICB2YXIgaGV4MywgcmVzdWx0O1xuICAgICAgaGV4MyA9IGhleC5tYXRjaCgvXiMoW2EtZlxcZF17MX0pKFthLWZcXGRdezF9KShbYS1mXFxkXXsxfSkkL2kpO1xuICAgICAgaWYgKGhleDMgIT0gbnVsbCkge1xuICAgICAgICBoZXggPSBcIiNcIiArIGhleDNbMV0gKyBoZXgzWzFdICsgaGV4M1syXSArIGhleDNbMl0gKyBoZXgzWzNdICsgaGV4M1szXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGhleC5tYXRjaCgvXiMoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kpO1xuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3Ioe1xuICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpLFxuICAgICAgICAgIGE6IDFcbiAgICAgICAgfSwgXCJoZXhcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgdmFyIG1hdGNoLCBfcmVmO1xuICAgICAgbWF0Y2ggPSByZ2IubWF0Y2goL15yZ2JhP1xcKChbMC05Ll0qKSwgPyhbMC05Ll0qKSwgPyhbMC05Ll0qKSg/OiwgPyhbMC05Ll0qKSk/XFwpJC8pO1xuICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih7XG4gICAgICAgICAgcjogcGFyc2VGbG9hdChtYXRjaFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdChtYXRjaFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdChtYXRjaFszXSksXG4gICAgICAgICAgYTogcGFyc2VGbG9hdCgoX3JlZiA9IG1hdGNoWzRdKSAhPSBudWxsID8gX3JlZiA6IDEpXG4gICAgICAgIH0sIG1hdGNoWzRdICE9IG51bGwgPyBcInJnYmFcIiA6IFwicmdiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIENvbG9yLmNvbXBvbmVudFRvSGV4ID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGhleDtcbiAgICAgIGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiMFwiICsgaGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCIjXCIgKyBDb2xvci5jb21wb25lbnRUb0hleCh0aGlzLnJnYi5yKSArIENvbG9yLmNvbXBvbmVudFRvSGV4KHRoaXMucmdiLmcpICsgQ29sb3IuY29tcG9uZW50VG9IZXgodGhpcy5yZ2IuYik7XG4gICAgfTtcblxuICAgIENvbG9yLnByb3RvdHlwZS50b1JnYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwicmdiKFwiICsgdGhpcy5yZ2IuciArIFwiLCBcIiArIHRoaXMucmdiLmcgKyBcIiwgXCIgKyB0aGlzLnJnYi5iICsgXCIpXCI7XG4gICAgfTtcblxuICAgIENvbG9yLnByb3RvdHlwZS50b1JnYmEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyB0aGlzLnJnYi5yICsgXCIsIFwiICsgdGhpcy5yZ2IuZyArIFwiLCBcIiArIHRoaXMucmdiLmIgKyBcIiwgXCIgKyB0aGlzLnJnYi5hICsgXCIpXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBDb2xvcjtcblxuICB9KSgpO1xuXG4gIEludGVycG9sYWJsZUNvbG9yID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEludGVycG9sYWJsZUNvbG9yKGNvbG9yKSB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLmZvcm1hdCA9IF9fYmluZCh0aGlzLmZvcm1hdCwgdGhpcyk7XG4gICAgICB0aGlzLmludGVycG9sYXRlID0gX19iaW5kKHRoaXMuaW50ZXJwb2xhdGUsIHRoaXMpO1xuICAgIH1cblxuICAgIEludGVycG9sYWJsZUNvbG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGVuZEludGVycG9sYWJsZSwgdCkge1xuICAgICAgdmFyIGVuZCwgaywgcmdiLCBzdGFydCwgdiwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBzdGFydCA9IHRoaXMuY29sb3I7XG4gICAgICBlbmQgPSBlbmRJbnRlcnBvbGFibGUuY29sb3I7XG4gICAgICByZ2IgPSB7fTtcbiAgICAgIF9yZWYgPSBbJ3InLCAnZycsICdiJ107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgayA9IF9yZWZbX2ldO1xuICAgICAgICB2ID0gTWF0aC5yb3VuZCgoZW5kLnJnYltrXSAtIHN0YXJ0LnJnYltrXSkgKiB0ICsgc3RhcnQucmdiW2tdKTtcbiAgICAgICAgcmdiW2tdID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCB2KSk7XG4gICAgICB9XG4gICAgICBrID0gXCJhXCI7XG4gICAgICB2ID0gcm91bmRmKChlbmQucmdiW2tdIC0gc3RhcnQucmdiW2tdKSAqIHQgKyBzdGFydC5yZ2Jba10sIDUpO1xuICAgICAgcmdiW2tdID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdikpO1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGFibGVDb2xvcihuZXcgQ29sb3IocmdiLCBlbmQuZm9ybWF0KSk7XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZUNvbG9yLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbG9yLmZvcm1hdCA9PT0gXCJoZXhcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvci50b0hleCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbG9yLmZvcm1hdCA9PT0gXCJyZ2JcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvci50b1JnYigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbG9yLmZvcm1hdCA9PT0gXCJyZ2JhXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IudG9SZ2JhKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEludGVycG9sYWJsZUNvbG9yLmNyZWF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY29sb3I7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbG9yID0gQ29sb3IuZnJvbUhleCh2YWx1ZSkgfHwgQ29sb3IuZnJvbVJnYih2YWx1ZSk7XG4gICAgICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYWJsZUNvbG9yKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW50ZXJwb2xhYmxlQ29sb3I7XG5cbiAgfSkoKTtcblxuICBEZWNvbXBvc2VkTWF0cml4MkQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRGVjb21wb3NlZE1hdHJpeDJEKHByb3BzKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmFwcGx5Um90YXRlQ2VudGVyID0gX19iaW5kKHRoaXMuYXBwbHlSb3RhdGVDZW50ZXIsIHRoaXMpO1xuICAgICAgdGhpcy5mb3JtYXQgPSBfX2JpbmQodGhpcy5mb3JtYXQsIHRoaXMpO1xuICAgICAgdGhpcy5pbnRlcnBvbGF0ZSA9IF9fYmluZCh0aGlzLmludGVycG9sYXRlLCB0aGlzKTtcbiAgICB9XG5cbiAgICBEZWNvbXBvc2VkTWF0cml4MkQucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oZW5kTWF0cml4LCB0KSB7XG4gICAgICB2YXIgaSwgaywgbmV3UHJvcHMsIF9pLCBfaiwgX2ssIF9sLCBfbGVuLCBfbGVuMSwgX3JlZiwgX3JlZjEsIF9yZWYyO1xuICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgIF9yZWYgPSBbJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBrID0gX3JlZltfaV07XG4gICAgICAgIG5ld1Byb3BzW2tdID0gW107XG4gICAgICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSB0aGlzLnByb3BzW2tdLmxlbmd0aDsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgICAgbmV3UHJvcHNba11baV0gPSAoZW5kTWF0cml4LnByb3BzW2tdW2ldIC0gdGhpcy5wcm9wc1trXVtpXSkgKiB0ICsgdGhpcy5wcm9wc1trXVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gX2sgPSAxOyBfayA8PSAyOyBpID0gKytfaykge1xuICAgICAgICBuZXdQcm9wc1sncm90YXRlJ11baV0gPSBlbmRNYXRyaXgucHJvcHNbJ3JvdGF0ZSddW2ldO1xuICAgICAgfVxuICAgICAgX3JlZjIgPSBbJ3NrZXcnXTtcbiAgICAgIGZvciAoX2wgPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2wgPCBfbGVuMTsgX2wrKykge1xuICAgICAgICBrID0gX3JlZjJbX2xdO1xuICAgICAgICBuZXdQcm9wc1trXSA9IChlbmRNYXRyaXgucHJvcHNba10gLSB0aGlzLnByb3BzW2tdKSAqIHQgKyB0aGlzLnByb3BzW2tdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEZWNvbXBvc2VkTWF0cml4MkQobmV3UHJvcHMpO1xuICAgIH07XG5cbiAgICBEZWNvbXBvc2VkTWF0cml4MkQucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHRoaXMucHJvcHMudHJhbnNsYXRlLmpvaW4oJywnKSkgKyBcIikgcm90YXRlKFwiICsgKHRoaXMucHJvcHMucm90YXRlLmpvaW4oJywnKSkgKyBcIikgc2tld1goXCIgKyB0aGlzLnByb3BzLnNrZXcgKyBcIikgc2NhbGUoXCIgKyAodGhpcy5wcm9wcy5zY2FsZS5qb2luKCcsJykpICsgXCIpXCI7XG4gICAgfTtcblxuICAgIERlY29tcG9zZWRNYXRyaXgyRC5wcm90b3R5cGUuYXBwbHlSb3RhdGVDZW50ZXIgPSBmdW5jdGlvbihyb3RhdGVDKSB7XG4gICAgICB2YXIgaSwgbSwgbTJkLCBuZWdhdGl2ZVRyYW5zbGF0ZSwgX2ksIF9yZXN1bHRzO1xuICAgICAgbSA9IGJhc2VTVkcuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgICBtID0gbS50cmFuc2xhdGUocm90YXRlQ1swXSwgcm90YXRlQ1sxXSk7XG4gICAgICBtID0gbS5yb3RhdGUodGhpcy5wcm9wcy5yb3RhdGVbMF0pO1xuICAgICAgbSA9IG0udHJhbnNsYXRlKC1yb3RhdGVDWzBdLCAtcm90YXRlQ1sxXSk7XG4gICAgICBtMmQgPSBuZXcgTWF0cml4MkQobSk7XG4gICAgICBuZWdhdGl2ZVRyYW5zbGF0ZSA9IG0yZC5kZWNvbXBvc2UoKS5wcm9wcy50cmFuc2xhdGU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8PSAxOyBpID0gKytfaSkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMucHJvcHMudHJhbnNsYXRlW2ldIC09IG5lZ2F0aXZlVHJhbnNsYXRlW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlY29tcG9zZWRNYXRyaXgyRDtcblxuICB9KSgpO1xuXG4gIGJhc2VTVkcgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQgIT09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKSA6IHZvaWQgMDtcblxuICBNYXRyaXgyRCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNYXRyaXgyRChtKSB7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5hcHBseVByb3BlcnRpZXMgPSBfX2JpbmQodGhpcy5hcHBseVByb3BlcnRpZXMsIHRoaXMpO1xuICAgICAgdGhpcy5kZWNvbXBvc2UgPSBfX2JpbmQodGhpcy5kZWNvbXBvc2UsIHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLm0pIHtcbiAgICAgICAgdGhpcy5tID0gYmFzZVNWRy5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBNYXRyaXgyRC5wcm90b3R5cGUuZGVjb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga3gsIGt5LCBreiwgcjAsIHIxO1xuICAgICAgcjAgPSBuZXcgVmVjdG9yKFt0aGlzLm0uYSwgdGhpcy5tLmJdKTtcbiAgICAgIHIxID0gbmV3IFZlY3RvcihbdGhpcy5tLmMsIHRoaXMubS5kXSk7XG4gICAgICBreCA9IHIwLmxlbmd0aCgpO1xuICAgICAga3ogPSByMC5kb3QocjEpO1xuICAgICAgcjAgPSByMC5ub3JtYWxpemUoKTtcbiAgICAgIGt5ID0gcjEuY29tYmluZShyMCwgMSwgLWt6KS5sZW5ndGgoKTtcbiAgICAgIHJldHVybiBuZXcgRGVjb21wb3NlZE1hdHJpeDJEKHtcbiAgICAgICAgdHJhbnNsYXRlOiBbdGhpcy5tLmUsIHRoaXMubS5mXSxcbiAgICAgICAgcm90YXRlOiBbTWF0aC5hdGFuMih0aGlzLm0uYiwgdGhpcy5tLmEpICogMTgwIC8gTWF0aC5QSSwgdGhpcy5yb3RhdGVDWCwgdGhpcy5yb3RhdGVDWV0sXG4gICAgICAgIHNjYWxlOiBba3gsIGt5XSxcbiAgICAgICAgc2tldzoga3ogLyBreSAqIDE4MCAvIE1hdGguUElcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYXRyaXgyRC5wcm90b3R5cGUuYXBwbHlQcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgdmFyIGhhc2gsIGssIHByb3BzLCB2LCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBoYXNoID0ge307XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wZXJ0aWVzW19pXTtcbiAgICAgICAgaGFzaFtwcm9wc1swXV0gPSBwcm9wc1sxXTtcbiAgICAgIH1cbiAgICAgIGZvciAoayBpbiBoYXNoKSB7XG4gICAgICAgIHYgPSBoYXNoW2tdO1xuICAgICAgICBpZiAoayA9PT0gXCJ0cmFuc2xhdGVYXCIpIHtcbiAgICAgICAgICB0aGlzLm0gPSB0aGlzLm0udHJhbnNsYXRlKHYsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IFwidHJhbnNsYXRlWVwiKSB7XG4gICAgICAgICAgdGhpcy5tID0gdGhpcy5tLnRyYW5zbGF0ZSgwLCB2KTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSBcInNjYWxlWFwiKSB7XG4gICAgICAgICAgdGhpcy5tID0gdGhpcy5tLnNjYWxlKHYsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IFwic2NhbGVZXCIpIHtcbiAgICAgICAgICB0aGlzLm0gPSB0aGlzLm0uc2NhbGUoMSwgdik7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PT0gXCJyb3RhdGVaXCIpIHtcbiAgICAgICAgICB0aGlzLm0gPSB0aGlzLm0ucm90YXRlKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IFwic2tld1hcIikge1xuICAgICAgICAgIHRoaXMubSA9IHRoaXMubS5za2V3WCh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSBcInNrZXdZXCIpIHtcbiAgICAgICAgICB0aGlzLm0gPSB0aGlzLm0uc2tld1kodik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucm90YXRlQ1ggPSAoX3JlZiA9IGhhc2gucm90YXRlQ1gpICE9IG51bGwgPyBfcmVmIDogMDtcbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZUNZID0gKF9yZWYxID0gaGFzaC5yb3RhdGVDWSkgIT0gbnVsbCA/IF9yZWYxIDogMDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hdHJpeDJEO1xuXG4gIH0pKCk7XG5cbiAgVmVjdG9yID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFZlY3RvcihlbHMpIHtcbiAgICAgIHRoaXMuZWxzID0gZWxzO1xuICAgICAgdGhpcy5jb21iaW5lID0gX19iaW5kKHRoaXMuY29tYmluZSwgdGhpcyk7XG4gICAgICB0aGlzLm5vcm1hbGl6ZSA9IF9fYmluZCh0aGlzLm5vcm1hbGl6ZSwgdGhpcyk7XG4gICAgICB0aGlzLmxlbmd0aCA9IF9fYmluZCh0aGlzLmxlbmd0aCwgdGhpcyk7XG4gICAgICB0aGlzLmNyb3NzID0gX19iaW5kKHRoaXMuY3Jvc3MsIHRoaXMpO1xuICAgICAgdGhpcy5kb3QgPSBfX2JpbmQodGhpcy5kb3QsIHRoaXMpO1xuICAgICAgdGhpcy5lID0gX19iaW5kKHRoaXMuZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgVmVjdG9yLnByb3RvdHlwZS5lID0gZnVuY3Rpb24oaSkge1xuICAgICAgaWYgKGkgPCAxIHx8IGkgPiB0aGlzLmVscy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHNbaSAtIDFdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgdmFyIFYsIG4sIHByb2R1Y3Q7XG4gICAgICBWID0gdmVjdG9yLmVscyB8fCB2ZWN0b3I7XG4gICAgICBwcm9kdWN0ID0gMDtcbiAgICAgIG4gPSB0aGlzLmVscy5sZW5ndGg7XG4gICAgICBpZiAobiAhPT0gVi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBuICs9IDE7XG4gICAgICB3aGlsZSAoLS1uKSB7XG4gICAgICAgIHByb2R1Y3QgKz0gdGhpcy5lbHNbbiAtIDFdICogVltuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9O1xuXG4gICAgVmVjdG9yLnByb3RvdHlwZS5jcm9zcyA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgdmFyIEEsIEI7XG4gICAgICBCID0gdmVjdG9yLmVscyB8fCB2ZWN0b3I7XG4gICAgICBpZiAodGhpcy5lbHMubGVuZ3RoICE9PSAzIHx8IEIubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgQSA9IHRoaXMuZWxzO1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoWyhBWzFdICogQlsyXSkgLSAoQVsyXSAqIEJbMV0pLCAoQVsyXSAqIEJbMF0pIC0gKEFbMF0gKiBCWzJdKSwgKEFbMF0gKiBCWzFdKSAtIChBWzFdICogQlswXSldKTtcbiAgICB9O1xuXG4gICAgVmVjdG9yLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhLCBlLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGEgPSAwO1xuICAgICAgX3JlZiA9IHRoaXMuZWxzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGUgPSBfcmVmW19pXTtcbiAgICAgICAgYSArPSBNYXRoLnBvdyhlLCAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoYSk7XG4gICAgfTtcblxuICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSwgaSwgbGVuZ3RoLCBuZXdFbGVtZW50cywgX3JlZjtcbiAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgX3JlZiA9IHRoaXMuZWxzO1xuICAgICAgZm9yIChpIGluIF9yZWYpIHtcbiAgICAgICAgZSA9IF9yZWZbaV07XG4gICAgICAgIG5ld0VsZW1lbnRzW2ldID0gZSAvIGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKG5ld0VsZW1lbnRzKTtcbiAgICB9O1xuXG4gICAgVmVjdG9yLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24oYiwgYXNjbCwgYnNjbCkge1xuICAgICAgdmFyIGksIHJlc3VsdCwgX2ksIF9yZWY7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHRoaXMuZWxzLmxlbmd0aDsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gKGFzY2wgKiB0aGlzLmVsc1tpXSkgKyAoYnNjbCAqIGIuZWxzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIHJldHVybiBWZWN0b3I7XG5cbiAgfSkoKTtcblxuICBEZWNvbXBvc2VkTWF0cml4ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIERlY29tcG9zZWRNYXRyaXgoKSB7XG4gICAgICB0aGlzLnRvTWF0cml4ID0gX19iaW5kKHRoaXMudG9NYXRyaXgsIHRoaXMpO1xuICAgICAgdGhpcy5mb3JtYXQgPSBfX2JpbmQodGhpcy5mb3JtYXQsIHRoaXMpO1xuICAgICAgdGhpcy5pbnRlcnBvbGF0ZSA9IF9fYmluZCh0aGlzLmludGVycG9sYXRlLCB0aGlzKTtcbiAgICB9XG5cbiAgICBEZWNvbXBvc2VkTWF0cml4LnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGRlY29tcG9zZWRCLCB0LCBvbmx5KSB7XG4gICAgICB2YXIgYW5nbGUsIGRlY29tcG9zZWQsIGRlY29tcG9zZWRBLCBpLCBpbnZzY2FsZSwgaW52dGgsIGssIHFhLCBxYiwgc2NhbGUsIHRoLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAob25seSA9PSBudWxsKSB7XG4gICAgICAgIG9ubHkgPSBudWxsO1xuICAgICAgfVxuICAgICAgZGVjb21wb3NlZEEgPSB0aGlzO1xuICAgICAgZGVjb21wb3NlZCA9IG5ldyBEZWNvbXBvc2VkTWF0cml4O1xuICAgICAgX3JlZiA9IFsndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3NrZXcnLCAncGVyc3BlY3RpdmUnXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBrID0gX3JlZltfaV07XG4gICAgICAgIGRlY29tcG9zZWRba10gPSBbXTtcbiAgICAgICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IGRlY29tcG9zZWRBW2tdLmxlbmd0aCAtIDE7IDAgPD0gX3JlZjEgPyBfaiA8PSBfcmVmMSA6IF9qID49IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgICAgaWYgKChvbmx5ID09IG51bGwpIHx8IG9ubHkuaW5kZXhPZihrKSA+IC0xIHx8IG9ubHkuaW5kZXhPZihcIlwiICsgayArIFsneCcsICd5JywgJ3onXVtpXSkgPiAtMSkge1xuICAgICAgICAgICAgZGVjb21wb3NlZFtrXVtpXSA9IChkZWNvbXBvc2VkQltrXVtpXSAtIGRlY29tcG9zZWRBW2tdW2ldKSAqIHQgKyBkZWNvbXBvc2VkQVtrXVtpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVjb21wb3NlZFtrXVtpXSA9IGRlY29tcG9zZWRBW2tdW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChvbmx5ID09IG51bGwpIHx8IG9ubHkuaW5kZXhPZigncm90YXRlJykgIT09IC0xKSB7XG4gICAgICAgIHFhID0gZGVjb21wb3NlZEEucXVhdGVybmlvbjtcbiAgICAgICAgcWIgPSBkZWNvbXBvc2VkQi5xdWF0ZXJuaW9uO1xuICAgICAgICBhbmdsZSA9IHFhWzBdICogcWJbMF0gKyBxYVsxXSAqIHFiWzFdICsgcWFbMl0gKiBxYlsyXSArIHFhWzNdICogcWJbM107XG4gICAgICAgIGlmIChhbmdsZSA8IDAuMCkge1xuICAgICAgICAgIGZvciAoaSA9IF9rID0gMDsgX2sgPD0gMzsgaSA9ICsrX2spIHtcbiAgICAgICAgICAgIHFhW2ldID0gLXFhW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbmdsZSA9IC1hbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5nbGUgKyAxLjAgPiAuMDUpIHtcbiAgICAgICAgICBpZiAoMS4wIC0gYW5nbGUgPj0gLjA1KSB7XG4gICAgICAgICAgICB0aCA9IE1hdGguYWNvcyhhbmdsZSk7XG4gICAgICAgICAgICBpbnZ0aCA9IDEuMCAvIE1hdGguc2luKHRoKTtcbiAgICAgICAgICAgIHNjYWxlID0gTWF0aC5zaW4odGggKiAoMS4wIC0gdCkpICogaW52dGg7XG4gICAgICAgICAgICBpbnZzY2FsZSA9IE1hdGguc2luKHRoICogdCkgKiBpbnZ0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbGUgPSAxLjAgLSB0O1xuICAgICAgICAgICAgaW52c2NhbGUgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxYlswXSA9IC1xYVsxXTtcbiAgICAgICAgICBxYlsxXSA9IHFhWzBdO1xuICAgICAgICAgIHFiWzJdID0gLXFhWzNdO1xuICAgICAgICAgIHFiWzNdID0gcWFbMl07XG4gICAgICAgICAgc2NhbGUgPSBNYXRoLnNpbihwaURvdWJsZSAqICguNSAtIHQpKTtcbiAgICAgICAgICBpbnZzY2FsZSA9IE1hdGguc2luKHBpRG91YmxlICogdCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb21wb3NlZC5xdWF0ZXJuaW9uID0gW107XG4gICAgICAgIGZvciAoaSA9IF9sID0gMDsgX2wgPD0gMzsgaSA9ICsrX2wpIHtcbiAgICAgICAgICBkZWNvbXBvc2VkLnF1YXRlcm5pb25baV0gPSBxYVtpXSAqIHNjYWxlICsgcWJbaV0gKiBpbnZzY2FsZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjb21wb3NlZC5xdWF0ZXJuaW9uID0gZGVjb21wb3NlZEEucXVhdGVybmlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvbXBvc2VkO1xuICAgIH07XG5cbiAgICBEZWNvbXBvc2VkTWF0cml4LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTWF0cml4KCkudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgRGVjb21wb3NlZE1hdHJpeC5wcm90b3R5cGUudG9NYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZWNvbXBvc2VkTWF0cml4LCBpLCBqLCBtYXRjaCwgbWF0cml4LCBxdWF0ZXJuaW9uLCBza2V3LCB0ZW1wLCB3LCB4LCB5LCB6LCBfaSwgX2osIF9rLCBfbDtcbiAgICAgIGRlY29tcG9zZWRNYXRyaXggPSB0aGlzO1xuICAgICAgbWF0cml4ID0gTWF0cml4LkkoNCk7XG4gICAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDw9IDM7IGkgPSArK19pKSB7XG4gICAgICAgIG1hdHJpeC5lbHNbaV1bM10gPSBkZWNvbXBvc2VkTWF0cml4LnBlcnNwZWN0aXZlW2ldO1xuICAgICAgfVxuICAgICAgcXVhdGVybmlvbiA9IGRlY29tcG9zZWRNYXRyaXgucXVhdGVybmlvbjtcbiAgICAgIHggPSBxdWF0ZXJuaW9uWzBdO1xuICAgICAgeSA9IHF1YXRlcm5pb25bMV07XG4gICAgICB6ID0gcXVhdGVybmlvblsyXTtcbiAgICAgIHcgPSBxdWF0ZXJuaW9uWzNdO1xuICAgICAgc2tldyA9IGRlY29tcG9zZWRNYXRyaXguc2tldztcbiAgICAgIG1hdGNoID0gW1sxLCAwXSwgWzIsIDBdLCBbMiwgMV1dO1xuICAgICAgZm9yIChpID0gX2ogPSAyOyBfaiA+PSAwOyBpID0gLS1faikge1xuICAgICAgICBpZiAoc2tld1tpXSkge1xuICAgICAgICAgIHRlbXAgPSBNYXRyaXguSSg0KTtcbiAgICAgICAgICB0ZW1wLmVsc1ttYXRjaFtpXVswXV1bbWF0Y2hbaV1bMV1dID0gc2tld1tpXTtcbiAgICAgICAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkodGVtcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hdHJpeCA9IG1hdHJpeC5tdWx0aXBseShuZXcgTWF0cml4KFtbMSAtIDIgKiAoeSAqIHkgKyB6ICogeiksIDIgKiAoeCAqIHkgLSB6ICogdyksIDIgKiAoeCAqIHogKyB5ICogdyksIDBdLCBbMiAqICh4ICogeSArIHogKiB3KSwgMSAtIDIgKiAoeCAqIHggKyB6ICogeiksIDIgKiAoeSAqIHogLSB4ICogdyksIDBdLCBbMiAqICh4ICogeiAtIHkgKiB3KSwgMiAqICh5ICogeiArIHggKiB3KSwgMSAtIDIgKiAoeCAqIHggKyB5ICogeSksIDBdLCBbMCwgMCwgMCwgMV1dKSk7XG4gICAgICBmb3IgKGkgPSBfayA9IDA7IF9rIDw9IDI7IGkgPSArK19rKSB7XG4gICAgICAgIGZvciAoaiA9IF9sID0gMDsgX2wgPD0gMjsgaiA9ICsrX2wpIHtcbiAgICAgICAgICBtYXRyaXguZWxzW2ldW2pdICo9IGRlY29tcG9zZWRNYXRyaXguc2NhbGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgbWF0cml4LmVsc1szXVtpXSA9IGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlY29tcG9zZWRNYXRyaXg7XG5cbiAgfSkoKTtcblxuICBNYXRyaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWF0cml4KGVscykge1xuICAgICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgICB0aGlzLnRvU3RyaW5nID0gX19iaW5kKHRoaXMudG9TdHJpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5kZWNvbXBvc2UgPSBfX2JpbmQodGhpcy5kZWNvbXBvc2UsIHRoaXMpO1xuICAgICAgdGhpcy5pbnZlcnNlID0gX19iaW5kKHRoaXMuaW52ZXJzZSwgdGhpcyk7XG4gICAgICB0aGlzLmF1Z21lbnQgPSBfX2JpbmQodGhpcy5hdWdtZW50LCB0aGlzKTtcbiAgICAgIHRoaXMudG9SaWdodFRyaWFuZ3VsYXIgPSBfX2JpbmQodGhpcy50b1JpZ2h0VHJpYW5ndWxhciwgdGhpcyk7XG4gICAgICB0aGlzLnRyYW5zcG9zZSA9IF9fYmluZCh0aGlzLnRyYW5zcG9zZSwgdGhpcyk7XG4gICAgICB0aGlzLm11bHRpcGx5ID0gX19iaW5kKHRoaXMubXVsdGlwbHksIHRoaXMpO1xuICAgICAgdGhpcy5kdXAgPSBfX2JpbmQodGhpcy5kdXAsIHRoaXMpO1xuICAgICAgdGhpcy5lID0gX19iaW5kKHRoaXMuZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgTWF0cml4LnByb3RvdHlwZS5lID0gZnVuY3Rpb24oaSwgaikge1xuICAgICAgaWYgKGkgPCAxIHx8IGkgPiB0aGlzLmVscy5sZW5ndGggfHwgaiA8IDEgfHwgaiA+IHRoaXMuZWxzWzBdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVsc1tpIC0gMV1baiAtIDFdO1xuICAgIH07XG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5lbHMpO1xuICAgIH07XG5cbiAgICBNYXRyaXgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICB2YXIgTSwgYywgY29scywgZWxlbWVudHMsIGksIGosIGtpLCBraiwgbmMsIG5pLCBuaiwgcmV0dXJuVmVjdG9yLCBzdW07XG4gICAgICByZXR1cm5WZWN0b3IgPSBtYXRyaXgubW9kdWx1cyA/IHRydWUgOiBmYWxzZTtcbiAgICAgIE0gPSBtYXRyaXguZWxzIHx8IG1hdHJpeDtcbiAgICAgIGlmICh0eXBlb2YgTVswXVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgTSA9IG5ldyBNYXRyaXgoTSkuZWxzO1xuICAgICAgfVxuICAgICAgbmkgPSB0aGlzLmVscy5sZW5ndGg7XG4gICAgICBraSA9IG5pO1xuICAgICAga2ogPSBNWzBdLmxlbmd0aDtcbiAgICAgIGNvbHMgPSB0aGlzLmVsc1swXS5sZW5ndGg7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgbmkgKz0gMTtcbiAgICAgIHdoaWxlICgtLW5pKSB7XG4gICAgICAgIGkgPSBraSAtIG5pO1xuICAgICAgICBlbGVtZW50c1tpXSA9IFtdO1xuICAgICAgICBuaiA9IGtqO1xuICAgICAgICBuaiArPSAxO1xuICAgICAgICB3aGlsZSAoLS1uaikge1xuICAgICAgICAgIGogPSBraiAtIG5qO1xuICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgbmMgPSBjb2xzO1xuICAgICAgICAgIG5jICs9IDE7XG4gICAgICAgICAgd2hpbGUgKC0tbmMpIHtcbiAgICAgICAgICAgIGMgPSBjb2xzIC0gbmM7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5lbHNbaV1bY10gKiBNW2NdW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50c1tpXVtqXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTSA9IG5ldyBNYXRyaXgoZWxlbWVudHMpO1xuICAgICAgaWYgKHJldHVyblZlY3Rvcikge1xuICAgICAgICByZXR1cm4gTS5jb2woMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTWF0cml4LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2xzLCBlbGVtZW50cywgaSwgaiwgbmksIG5qLCByb3dzO1xuICAgICAgcm93cyA9IHRoaXMuZWxzLmxlbmd0aDtcbiAgICAgIGNvbHMgPSB0aGlzLmVsc1swXS5sZW5ndGg7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgbmkgPSBjb2xzO1xuICAgICAgbmkgKz0gMTtcbiAgICAgIHdoaWxlICgtLW5pKSB7XG4gICAgICAgIGkgPSBjb2xzIC0gbmk7XG4gICAgICAgIGVsZW1lbnRzW2ldID0gW107XG4gICAgICAgIG5qID0gcm93cztcbiAgICAgICAgbmogKz0gMTtcbiAgICAgICAgd2hpbGUgKC0tbmopIHtcbiAgICAgICAgICBqID0gcm93cyAtIG5qO1xuICAgICAgICAgIGVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbHNbal1baV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTWF0cml4KGVsZW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTWF0cml4LnByb3RvdHlwZS50b1JpZ2h0VHJpYW5ndWxhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIE0sIGVscywgaSwgaiwgaywga3AsIG11bHRpcGxpZXIsIG4sIG5wLCBwLCBfaSwgX2osIF9yZWYsIF9yZWYxO1xuICAgICAgTSA9IHRoaXMuZHVwKCk7XG4gICAgICBuID0gdGhpcy5lbHMubGVuZ3RoO1xuICAgICAgayA9IG47XG4gICAgICBrcCA9IHRoaXMuZWxzWzBdLmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLW4pIHtcbiAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICBpZiAoTS5lbHNbaV1baV0gPT09IDApIHtcbiAgICAgICAgICBmb3IgKGogPSBfaSA9IF9yZWYgPSBpICsgMTsgX3JlZiA8PSBrID8gX2kgPCBrIDogX2kgPiBrOyBqID0gX3JlZiA8PSBrID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgIGlmIChNLmVsc1tqXVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgICBlbHMgPSBbXTtcbiAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgbnAgKz0gMTtcbiAgICAgICAgICAgICAgd2hpbGUgKC0tbnApIHtcbiAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICBlbHMucHVzaChNLmVsc1tpXVtwXSArIE0uZWxzW2pdW3BdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBNLmVsc1tpXSA9IGVscztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChNLmVsc1tpXVtpXSAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaiA9IF9qID0gX3JlZjEgPSBpICsgMTsgX3JlZjEgPD0gayA/IF9qIDwgayA6IF9qID4gazsgaiA9IF9yZWYxIDw9IGsgPyArK19qIDogLS1faikge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IE0uZWxzW2pdW2ldIC8gTS5lbHNbaV1baV07XG4gICAgICAgICAgICBlbHMgPSBbXTtcbiAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICBucCArPSAxO1xuICAgICAgICAgICAgd2hpbGUgKC0tbnApIHtcbiAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgIGVscy5wdXNoKHAgPD0gaSA/IDAgOiBNLmVsc1tqXVtwXSAtIE0uZWxzW2ldW3BdICogbXVsdGlwbGllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNLmVsc1tqXSA9IGVscztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBNO1xuICAgIH07XG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmF1Z21lbnQgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgIHZhciBNLCBULCBjb2xzLCBpLCBqLCBraSwga2osIG5pLCBuajtcbiAgICAgIE0gPSBtYXRyaXguZWxzIHx8IG1hdHJpeDtcbiAgICAgIGlmICh0eXBlb2YgTVswXVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgTSA9IG5ldyBNYXRyaXgoTSkuZWxzO1xuICAgICAgfVxuICAgICAgVCA9IHRoaXMuZHVwKCk7XG4gICAgICBjb2xzID0gVC5lbHNbMF0ubGVuZ3RoO1xuICAgICAgbmkgPSBULmVscy5sZW5ndGg7XG4gICAgICBraSA9IG5pO1xuICAgICAga2ogPSBNWzBdLmxlbmd0aDtcbiAgICAgIGlmIChuaSAhPT0gTS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBuaSArPSAxO1xuICAgICAgd2hpbGUgKC0tbmkpIHtcbiAgICAgICAgaSA9IGtpIC0gbmk7XG4gICAgICAgIG5qID0ga2o7XG4gICAgICAgIG5qICs9IDE7XG4gICAgICAgIHdoaWxlICgtLW5qKSB7XG4gICAgICAgICAgaiA9IGtqIC0gbmo7XG4gICAgICAgICAgVC5lbHNbaV1bY29scyArIGpdID0gTVtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFQ7XG4gICAgfTtcblxuICAgIE1hdHJpeC5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIE0sIGRpdmlzb3IsIGVscywgaSwgaW52ZXJzZV9lbGVtZW50cywgaiwga2ksIGtwLCBuZXdfZWxlbWVudCwgbmksIG5wLCBwLCBfaTtcbiAgICAgIG5pID0gdGhpcy5lbHMubGVuZ3RoO1xuICAgICAga2kgPSBuaTtcbiAgICAgIE0gPSB0aGlzLmF1Z21lbnQoTWF0cml4LkkobmkpKS50b1JpZ2h0VHJpYW5ndWxhcigpO1xuICAgICAga3AgPSBNLmVsc1swXS5sZW5ndGg7XG4gICAgICBpbnZlcnNlX2VsZW1lbnRzID0gW107XG4gICAgICBuaSArPSAxO1xuICAgICAgd2hpbGUgKC0tbmkpIHtcbiAgICAgICAgaSA9IG5pIC0gMTtcbiAgICAgICAgZWxzID0gW107XG4gICAgICAgIG5wID0ga3A7XG4gICAgICAgIGludmVyc2VfZWxlbWVudHNbaV0gPSBbXTtcbiAgICAgICAgZGl2aXNvciA9IE0uZWxzW2ldW2ldO1xuICAgICAgICBucCArPSAxO1xuICAgICAgICB3aGlsZSAoLS1ucCkge1xuICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgIG5ld19lbGVtZW50ID0gTS5lbHNbaV1bcF0gLyBkaXZpc29yO1xuICAgICAgICAgIGVscy5wdXNoKG5ld19lbGVtZW50KTtcbiAgICAgICAgICBpZiAocCA+PSBraSkge1xuICAgICAgICAgICAgaW52ZXJzZV9lbGVtZW50c1tpXS5wdXNoKG5ld19lbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTS5lbHNbaV0gPSBlbHM7XG4gICAgICAgIGZvciAoaiA9IF9pID0gMDsgMCA8PSBpID8gX2kgPCBpIDogX2kgPiBpOyBqID0gMCA8PSBpID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICBlbHMgPSBbXTtcbiAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgIG5wICs9IDE7XG4gICAgICAgICAgd2hpbGUgKC0tbnApIHtcbiAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgZWxzLnB1c2goTS5lbHNbal1bcF0gLSBNLmVsc1tpXVtwXSAqIE0uZWxzW2pdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgTS5lbHNbal0gPSBlbHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTWF0cml4KGludmVyc2VfZWxlbWVudHMpO1xuICAgIH07XG5cbiAgICBNYXRyaXguSSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBlbHMsIGksIGosIGssIG5qO1xuICAgICAgZWxzID0gW107XG4gICAgICBrID0gbjtcbiAgICAgIG4gKz0gMTtcbiAgICAgIHdoaWxlICgtLW4pIHtcbiAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICBlbHNbaV0gPSBbXTtcbiAgICAgICAgbmogPSBrO1xuICAgICAgICBuaiArPSAxO1xuICAgICAgICB3aGlsZSAoLS1uaikge1xuICAgICAgICAgIGogPSBrIC0gbmo7XG4gICAgICAgICAgZWxzW2ldW2pdID0gaSA9PT0gaiA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeChlbHMpO1xuICAgIH07XG5cbiAgICBNYXRyaXgucHJvdG90eXBlLmRlY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVscywgaSwgaW52ZXJzZVBlcnNwZWN0aXZlTWF0cml4LCBqLCBrLCBtYXRyaXgsIHBkdW0zLCBwZXJzcGVjdGl2ZSwgcGVyc3BlY3RpdmVNYXRyaXgsIHF1YXRlcm5pb24sIHJlc3VsdCwgcmlnaHRIYW5kU2lkZSwgcm90YXRlLCByb3csIHJvd0VsZW1lbnQsIHMsIHNjYWxlLCBza2V3LCB0LCB0cmFuc2xhdGUsIHRyYW5zcG9zZWRJbnZlcnNlUGVyc3BlY3RpdmVNYXRyaXgsIHR5cGUsIHR5cGVLZXksIHYsIHcsIHgsIHksIHosIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yO1xuICAgICAgbWF0cml4ID0gdGhpcztcbiAgICAgIHRyYW5zbGF0ZSA9IFtdO1xuICAgICAgc2NhbGUgPSBbXTtcbiAgICAgIHNrZXcgPSBbXTtcbiAgICAgIHF1YXRlcm5pb24gPSBbXTtcbiAgICAgIHBlcnNwZWN0aXZlID0gW107XG4gICAgICBlbHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPD0gMzsgaSA9ICsrX2kpIHtcbiAgICAgICAgZWxzW2ldID0gW107XG4gICAgICAgIGZvciAoaiA9IF9qID0gMDsgX2ogPD0gMzsgaiA9ICsrX2opIHtcbiAgICAgICAgICBlbHNbaV1bal0gPSBtYXRyaXguZWxzW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxzWzNdWzNdID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IF9rID0gMDsgX2sgPD0gMzsgaSA9ICsrX2spIHtcbiAgICAgICAgZm9yIChqID0gX2wgPSAwOyBfbCA8PSAzOyBqID0gKytfbCkge1xuICAgICAgICAgIGVsc1tpXVtqXSAvPSBlbHNbM11bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlcnNwZWN0aXZlTWF0cml4ID0gbWF0cml4LmR1cCgpO1xuICAgICAgZm9yIChpID0gX20gPSAwOyBfbSA8PSAyOyBpID0gKytfbSkge1xuICAgICAgICBwZXJzcGVjdGl2ZU1hdHJpeC5lbHNbaV1bM10gPSAwO1xuICAgICAgfVxuICAgICAgcGVyc3BlY3RpdmVNYXRyaXguZWxzWzNdWzNdID0gMTtcbiAgICAgIGlmIChlbHNbMF1bM10gIT09IDAgfHwgZWxzWzFdWzNdICE9PSAwIHx8IGVsc1syXVszXSAhPT0gMCkge1xuICAgICAgICByaWdodEhhbmRTaWRlID0gbmV3IFZlY3RvcihlbHMuc2xpY2UoMCwgNClbM10pO1xuICAgICAgICBpbnZlcnNlUGVyc3BlY3RpdmVNYXRyaXggPSBwZXJzcGVjdGl2ZU1hdHJpeC5pbnZlcnNlKCk7XG4gICAgICAgIHRyYW5zcG9zZWRJbnZlcnNlUGVyc3BlY3RpdmVNYXRyaXggPSBpbnZlcnNlUGVyc3BlY3RpdmVNYXRyaXgudHJhbnNwb3NlKCk7XG4gICAgICAgIHBlcnNwZWN0aXZlID0gdHJhbnNwb3NlZEludmVyc2VQZXJzcGVjdGl2ZU1hdHJpeC5tdWx0aXBseShyaWdodEhhbmRTaWRlKS5lbHM7XG4gICAgICAgIGZvciAoaSA9IF9uID0gMDsgX24gPD0gMjsgaSA9ICsrX24pIHtcbiAgICAgICAgICBlbHNbaV1bM10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc1szXVszXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJzcGVjdGl2ZSA9IFswLCAwLCAwLCAxXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IF9vID0gMDsgX28gPD0gMjsgaSA9ICsrX28pIHtcbiAgICAgICAgdHJhbnNsYXRlW2ldID0gZWxzWzNdW2ldO1xuICAgICAgICBlbHNbM11baV0gPSAwO1xuICAgICAgfVxuICAgICAgcm93ID0gW107XG4gICAgICBmb3IgKGkgPSBfcCA9IDA7IF9wIDw9IDI7IGkgPSArK19wKSB7XG4gICAgICAgIHJvd1tpXSA9IG5ldyBWZWN0b3IoZWxzW2ldLnNsaWNlKDAsIDMpKTtcbiAgICAgIH1cbiAgICAgIHNjYWxlWzBdID0gcm93WzBdLmxlbmd0aCgpO1xuICAgICAgcm93WzBdID0gcm93WzBdLm5vcm1hbGl6ZSgpO1xuICAgICAgc2tld1swXSA9IHJvd1swXS5kb3Qocm93WzFdKTtcbiAgICAgIHJvd1sxXSA9IHJvd1sxXS5jb21iaW5lKHJvd1swXSwgMS4wLCAtc2tld1swXSk7XG4gICAgICBzY2FsZVsxXSA9IHJvd1sxXS5sZW5ndGgoKTtcbiAgICAgIHJvd1sxXSA9IHJvd1sxXS5ub3JtYWxpemUoKTtcbiAgICAgIHNrZXdbMF0gLz0gc2NhbGVbMV07XG4gICAgICBza2V3WzFdID0gcm93WzBdLmRvdChyb3dbMl0pO1xuICAgICAgcm93WzJdID0gcm93WzJdLmNvbWJpbmUocm93WzBdLCAxLjAsIC1za2V3WzFdKTtcbiAgICAgIHNrZXdbMl0gPSByb3dbMV0uZG90KHJvd1syXSk7XG4gICAgICByb3dbMl0gPSByb3dbMl0uY29tYmluZShyb3dbMV0sIDEuMCwgLXNrZXdbMl0pO1xuICAgICAgc2NhbGVbMl0gPSByb3dbMl0ubGVuZ3RoKCk7XG4gICAgICByb3dbMl0gPSByb3dbMl0ubm9ybWFsaXplKCk7XG4gICAgICBza2V3WzFdIC89IHNjYWxlWzJdO1xuICAgICAgc2tld1syXSAvPSBzY2FsZVsyXTtcbiAgICAgIHBkdW0zID0gcm93WzFdLmNyb3NzKHJvd1syXSk7XG4gICAgICBpZiAocm93WzBdLmRvdChwZHVtMykgPCAwKSB7XG4gICAgICAgIGZvciAoaSA9IF9xID0gMDsgX3EgPD0gMjsgaSA9ICsrX3EpIHtcbiAgICAgICAgICBzY2FsZVtpXSAqPSAtMTtcbiAgICAgICAgICBmb3IgKGogPSBfciA9IDA7IF9yIDw9IDI7IGogPSArK19yKSB7XG4gICAgICAgICAgICByb3dbaV0uZWxzW2pdICo9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm93RWxlbWVudCA9IGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJvd1tpbmRleF0uZWxzW2VsZW1lbnRJbmRleF07XG4gICAgICB9O1xuICAgICAgcm90YXRlID0gW107XG4gICAgICByb3RhdGVbMV0gPSBNYXRoLmFzaW4oLXJvd0VsZW1lbnQoMCwgMikpO1xuICAgICAgaWYgKE1hdGguY29zKHJvdGF0ZVsxXSkgIT09IDApIHtcbiAgICAgICAgcm90YXRlWzBdID0gTWF0aC5hdGFuMihyb3dFbGVtZW50KDEsIDIpLCByb3dFbGVtZW50KDIsIDIpKTtcbiAgICAgICAgcm90YXRlWzJdID0gTWF0aC5hdGFuMihyb3dFbGVtZW50KDAsIDEpLCByb3dFbGVtZW50KDAsIDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0ZVswXSA9IE1hdGguYXRhbjIoLXJvd0VsZW1lbnQoMiwgMCksIHJvd0VsZW1lbnQoMSwgMSkpO1xuICAgICAgICByb3RhdGVbMV0gPSAwO1xuICAgICAgfVxuICAgICAgdCA9IHJvd0VsZW1lbnQoMCwgMCkgKyByb3dFbGVtZW50KDEsIDEpICsgcm93RWxlbWVudCgyLCAyKSArIDEuMDtcbiAgICAgIGlmICh0ID4gMWUtNCkge1xuICAgICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KHQpO1xuICAgICAgICB3ID0gMC4yNSAvIHM7XG4gICAgICAgIHggPSAocm93RWxlbWVudCgyLCAxKSAtIHJvd0VsZW1lbnQoMSwgMikpICogcztcbiAgICAgICAgeSA9IChyb3dFbGVtZW50KDAsIDIpIC0gcm93RWxlbWVudCgyLCAwKSkgKiBzO1xuICAgICAgICB6ID0gKHJvd0VsZW1lbnQoMSwgMCkgLSByb3dFbGVtZW50KDAsIDEpKSAqIHM7XG4gICAgICB9IGVsc2UgaWYgKChyb3dFbGVtZW50KDAsIDApID4gcm93RWxlbWVudCgxLCAxKSkgJiYgKHJvd0VsZW1lbnQoMCwgMCkgPiByb3dFbGVtZW50KDIsIDIpKSkge1xuICAgICAgICBzID0gTWF0aC5zcXJ0KDEuMCArIHJvd0VsZW1lbnQoMCwgMCkgLSByb3dFbGVtZW50KDEsIDEpIC0gcm93RWxlbWVudCgyLCAyKSkgKiAyLjA7XG4gICAgICAgIHggPSAwLjI1ICogcztcbiAgICAgICAgeSA9IChyb3dFbGVtZW50KDAsIDEpICsgcm93RWxlbWVudCgxLCAwKSkgLyBzO1xuICAgICAgICB6ID0gKHJvd0VsZW1lbnQoMCwgMikgKyByb3dFbGVtZW50KDIsIDApKSAvIHM7XG4gICAgICAgIHcgPSAocm93RWxlbWVudCgyLCAxKSAtIHJvd0VsZW1lbnQoMSwgMikpIC8gcztcbiAgICAgIH0gZWxzZSBpZiAocm93RWxlbWVudCgxLCAxKSA+IHJvd0VsZW1lbnQoMiwgMikpIHtcbiAgICAgICAgcyA9IE1hdGguc3FydCgxLjAgKyByb3dFbGVtZW50KDEsIDEpIC0gcm93RWxlbWVudCgwLCAwKSAtIHJvd0VsZW1lbnQoMiwgMikpICogMi4wO1xuICAgICAgICB4ID0gKHJvd0VsZW1lbnQoMCwgMSkgKyByb3dFbGVtZW50KDEsIDApKSAvIHM7XG4gICAgICAgIHkgPSAwLjI1ICogcztcbiAgICAgICAgeiA9IChyb3dFbGVtZW50KDEsIDIpICsgcm93RWxlbWVudCgyLCAxKSkgLyBzO1xuICAgICAgICB3ID0gKHJvd0VsZW1lbnQoMCwgMikgLSByb3dFbGVtZW50KDIsIDApKSAvIHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gTWF0aC5zcXJ0KDEuMCArIHJvd0VsZW1lbnQoMiwgMikgLSByb3dFbGVtZW50KDAsIDApIC0gcm93RWxlbWVudCgxLCAxKSkgKiAyLjA7XG4gICAgICAgIHggPSAocm93RWxlbWVudCgwLCAyKSArIHJvd0VsZW1lbnQoMiwgMCkpIC8gcztcbiAgICAgICAgeSA9IChyb3dFbGVtZW50KDEsIDIpICsgcm93RWxlbWVudCgyLCAxKSkgLyBzO1xuICAgICAgICB6ID0gMC4yNSAqIHM7XG4gICAgICAgIHcgPSAocm93RWxlbWVudCgxLCAwKSAtIHJvd0VsZW1lbnQoMCwgMSkpIC8gcztcbiAgICAgIH1cbiAgICAgIHF1YXRlcm5pb24gPSBbeCwgeSwgeiwgd107XG4gICAgICByZXN1bHQgPSBuZXcgRGVjb21wb3NlZE1hdHJpeDtcbiAgICAgIHJlc3VsdC50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4gICAgICByZXN1bHQuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHJlc3VsdC5za2V3ID0gc2tldztcbiAgICAgIHJlc3VsdC5xdWF0ZXJuaW9uID0gcXVhdGVybmlvbjtcbiAgICAgIHJlc3VsdC5wZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xuICAgICAgcmVzdWx0LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgICAgIGZvciAodHlwZUtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgdHlwZSA9IHJlc3VsdFt0eXBlS2V5XTtcbiAgICAgICAgZm9yIChrIGluIHR5cGUpIHtcbiAgICAgICAgICB2ID0gdHlwZVtrXTtcbiAgICAgICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgICAgIHR5cGVba10gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTWF0cml4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGosIHN0ciwgX2ksIF9qO1xuICAgICAgc3RyID0gJ21hdHJpeDNkKCc7XG4gICAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDw9IDM7IGkgPSArK19pKSB7XG4gICAgICAgIGZvciAoaiA9IF9qID0gMDsgX2ogPD0gMzsgaiA9ICsrX2opIHtcbiAgICAgICAgICBzdHIgKz0gcm91bmRmKHRoaXMuZWxzW2ldW2pdLCAxMCk7XG4gICAgICAgICAgaWYgKCEoaSA9PT0gMyAmJiBqID09PSAzKSkge1xuICAgICAgICAgICAgc3RyICs9ICcsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0ciArPSAnKSc7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICBNYXRyaXgubWF0cml4Rm9yVHJhbnNmb3JtID0gY2FjaGVGbihmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciBtYXRyaXhFbCwgcmVzdWx0LCBzdHlsZSwgX3JlZiwgX3JlZjEsIF9yZWYyO1xuICAgICAgbWF0cml4RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hdHJpeEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIG1hdHJpeEVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIG1hdHJpeEVsLnN0eWxlW3Byb3BlcnR5V2l0aFByZWZpeChcInRyYW5zZm9ybVwiKV0gPSB0cmFuc2Zvcm07XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1hdHJpeEVsKTtcbiAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobWF0cml4RWwsIG51bGwpO1xuICAgICAgcmVzdWx0ID0gKF9yZWYgPSAoX3JlZjEgPSBzdHlsZS50cmFuc2Zvcm0pICE9IG51bGwgPyBfcmVmMSA6IHN0eWxlW3Byb3BlcnR5V2l0aFByZWZpeChcInRyYW5zZm9ybVwiKV0pICE9IG51bGwgPyBfcmVmIDogKF9yZWYyID0gZHluYW1pY3MudGVzdHMpICE9IG51bGwgPyBfcmVmMi5tYXRyaXhGb3JUcmFuc2Zvcm0odHJhbnNmb3JtKSA6IHZvaWQgMDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobWF0cml4RWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIE1hdHJpeC5mcm9tVHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICB2YXIgZGlnaXRzLCBlbGVtZW50cywgaSwgbWF0Y2gsIG1hdHJpeEVsZW1lbnRzLCBfaTtcbiAgICAgIG1hdGNoID0gdHJhbnNmb3JtICE9IG51bGwgPyB0cmFuc2Zvcm0ubWF0Y2goL21hdHJpeDM/ZD9cXCgoWy0wLTksZSBcXC5dKilcXCkvKSA6IHZvaWQgMDtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBkaWdpdHMgPSBtYXRjaFsxXS5zcGxpdCgnLCcpO1xuICAgICAgICBkaWdpdHMgPSBkaWdpdHMubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgICBpZiAoZGlnaXRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgIGVsZW1lbnRzID0gW2RpZ2l0c1swXSwgZGlnaXRzWzFdLCAwLCAwLCBkaWdpdHNbMl0sIGRpZ2l0c1szXSwgMCwgMCwgMCwgMCwgMSwgMCwgZGlnaXRzWzRdLCBkaWdpdHNbNV0sIDAsIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzID0gZGlnaXRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50cyA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgIH1cbiAgICAgIG1hdHJpeEVsZW1lbnRzID0gW107XG4gICAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDw9IDM7IGkgPSArK19pKSB7XG4gICAgICAgIG1hdHJpeEVsZW1lbnRzLnB1c2goZWxlbWVudHMuc2xpY2UoaSAqIDQsIGkgKiA0ICsgNCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobWF0cml4RWxlbWVudHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWF0cml4O1xuXG4gIH0pKCk7XG5cbiAgcHJlZml4Rm9yID0gY2FjaGVGbihmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHZhciBrLCBwcmVmaXgsIHByb3AsIHByb3BBcnJheSwgcHJvcGVydHlOYW1lLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmO1xuICAgIGlmIChkb2N1bWVudC5ib2R5LnN0eWxlW3Byb3BlcnR5XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHByb3BBcnJheSA9IHByb3BlcnR5LnNwbGl0KCctJyk7XG4gICAgcHJvcGVydHlOYW1lID0gXCJcIjtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHByb3BBcnJheS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgcHJvcCA9IHByb3BBcnJheVtfaV07XG4gICAgICBwcm9wZXJ0eU5hbWUgKz0gcHJvcC5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBfcmVmID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG4gICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgIHByZWZpeCA9IF9yZWZbX2pdO1xuICAgICAgayA9IHByZWZpeCArIHByb3BlcnR5TmFtZTtcbiAgICAgIGlmIChkb2N1bWVudC5ib2R5LnN0eWxlW2tdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcblxuICBwcm9wZXJ0eVdpdGhQcmVmaXggPSBjYWNoZUZuKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeDtcbiAgICBwcmVmaXggPSBwcmVmaXhGb3IocHJvcGVydHkpO1xuICAgIGlmIChwcmVmaXggPT09ICdNb3onKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIChwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGlmIChwcmVmaXggIT09ICcnKSB7XG4gICAgICByZXR1cm4gXCItXCIgKyAocHJlZml4LnRvTG93ZXJDYXNlKCkpICsgXCItXCIgKyAodG9EYXNoZWQocHJvcGVydHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvRGFzaGVkKHByb3BlcnR5KTtcbiAgfSk7XG5cbiAgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogdm9pZCAwO1xuXG4gIGFuaW1hdGlvbnMgPSBbXTtcblxuICBhbmltYXRpb25zVGltZW91dHMgPSBbXTtcblxuICBzbG93ID0gZmFsc2U7XG5cbiAgc2xvd1JhdGlvID0gMTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSA2OCAmJiBlLnNoaWZ0S2V5ICYmIGUuY3RybEtleSkge1xuICAgICAgICByZXR1cm4gZHluYW1pY3MudG9nZ2xlU2xvdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJBRiA9PSBudWxsKSB7XG4gICAgbGFzdFRpbWUgPSAwO1xuICAgIHJBRiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgY3VyclRpbWUsIGlkLCB0aW1lVG9DYWxsO1xuICAgICAgY3VyclRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICB9XG5cbiAgcnVuTG9vcFJ1bm5pbmcgPSBmYWxzZTtcblxuICBydW5Mb29wUGF1c2VkID0gZmFsc2U7XG5cbiAgc3RhcnRSdW5Mb29wID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFydW5Mb29wUnVubmluZykge1xuICAgICAgcnVuTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJBRihydW5Mb29wVGljayk7XG4gICAgfVxuICB9O1xuXG4gIHJ1bkxvb3BUaWNrID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBhbmltYXRpb24sIHRvUmVtb3ZlQW5pbWF0aW9ucywgX2ksIF9sZW47XG4gICAgaWYgKHJ1bkxvb3BQYXVzZWQpIHtcbiAgICAgIHJBRihydW5Mb29wVGljayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvUmVtb3ZlQW5pbWF0aW9ucyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYW5pbWF0aW9ucy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1tfaV07XG4gICAgICBpZiAoIWFuaW1hdGlvblRpY2sodCwgYW5pbWF0aW9uKSkge1xuICAgICAgICB0b1JlbW92ZUFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBhbmltYXRpb25zID0gYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gdG9SZW1vdmVBbmltYXRpb25zLmluZGV4T2YoYW5pbWF0aW9uKSA9PT0gLTE7XG4gICAgfSk7XG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcnVuTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJBRihydW5Mb29wVGljayk7XG4gICAgfVxuICB9O1xuXG4gIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbih0LCBhbmltYXRpb24pIHtcbiAgICB2YXIga2V5LCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgdHQsIHksIF9iYXNlLCBfYmFzZTEsIF9yZWY7XG4gICAgaWYgKGFuaW1hdGlvbi50U3RhcnQgPT0gbnVsbCkge1xuICAgICAgYW5pbWF0aW9uLnRTdGFydCA9IHQ7XG4gICAgfVxuICAgIHR0ID0gKHQgLSBhbmltYXRpb24udFN0YXJ0KSAvIGFuaW1hdGlvbi5vcHRpb25zLmR1cmF0aW9uO1xuICAgIHkgPSBhbmltYXRpb24uY3VydmUodHQpO1xuICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICBpZiAodHQgPj0gMSkge1xuICAgICAgaWYgKGFuaW1hdGlvbi5jdXJ2ZS5yZXR1cm5zVG9TZWxmKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBhbmltYXRpb24ucHJvcGVydGllcy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBhbmltYXRpb24ucHJvcGVydGllcy5lbmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZWYgPSBhbmltYXRpb24ucHJvcGVydGllcy5zdGFydDtcbiAgICAgIGZvciAoa2V5IGluIF9yZWYpIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmW2tleV07XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IGludGVycG9sYXRlKHByb3BlcnR5LCBhbmltYXRpb24ucHJvcGVydGllcy5lbmRba2V5XSwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5RnJhbWUoYW5pbWF0aW9uLmVsLCBwcm9wZXJ0aWVzKTtcbiAgICBpZiAodHlwZW9mIChfYmFzZSA9IGFuaW1hdGlvbi5vcHRpb25zKS5jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgX2Jhc2UuY2hhbmdlKGFuaW1hdGlvbi5lbCk7XG4gICAgfVxuICAgIGlmICh0dCA+PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIChfYmFzZTEgPSBhbmltYXRpb24ub3B0aW9ucykuY29tcGxldGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBfYmFzZTEuY29tcGxldGUoYW5pbWF0aW9uLmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR0IDwgMTtcbiAgfTtcblxuICBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHkpIHtcbiAgICBpZiAoKHN0YXJ0ICE9IG51bGwpICYmIChzdGFydC5pbnRlcnBvbGF0ZSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0LmludGVycG9sYXRlKGVuZCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24oZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMsIHRpbWVvdXRJZCkge1xuICAgIHZhciBlbmRQcm9wZXJ0aWVzLCBpbnRlcnBvbGFibGUsIGlzU1ZHLCBrLCBtYXRyaXgsIHN0YXJ0UHJvcGVydGllcywgdHJhbnNmb3JtcywgdjtcbiAgICBpZiAodGltZW91dElkICE9IG51bGwpIHtcbiAgICAgIGFuaW1hdGlvbnNUaW1lb3V0cyA9IGFuaW1hdGlvbnNUaW1lb3V0cy5maWx0ZXIoZnVuY3Rpb24odGltZW91dCkge1xuICAgICAgICByZXR1cm4gdGltZW91dC5pZCAhPT0gdGltZW91dElkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGR5bmFtaWNzLnN0b3AoZWwsIHtcbiAgICAgIHRpbWVvdXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLmFuaW1hdGVkKSB7XG4gICAgICBkeW5hbWljcy5jc3MoZWwsIHByb3BlcnRpZXMpO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbXBsZXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wbGV0ZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvcGVydGllcyA9IHBhcnNlUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICBzdGFydFByb3BlcnRpZXMgPSBnZXRDdXJyZW50UHJvcGVydGllcyhlbCwgT2JqZWN0LmtleXMocHJvcGVydGllcykpO1xuICAgIGVuZFByb3BlcnRpZXMgPSB7fTtcbiAgICB0cmFuc2Zvcm1zID0gW107XG4gICAgZm9yIChrIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIHYgPSBwcm9wZXJ0aWVzW2tdO1xuICAgICAgaWYgKChlbC5zdHlsZSAhPSBudWxsKSAmJiB0cmFuc2Zvcm1Qcm9wZXJ0aWVzLmNvbnRhaW5zKGspKSB7XG4gICAgICAgIHRyYW5zZm9ybXMucHVzaChbaywgdl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhYmxlID0gY3JlYXRlSW50ZXJwb2xhYmxlKHYpO1xuICAgICAgICBpZiAoaW50ZXJwb2xhYmxlIGluc3RhbmNlb2YgSW50ZXJwb2xhYmxlTnVtYmVyICYmIChlbC5zdHlsZSAhPSBudWxsKSkge1xuICAgICAgICAgIGludGVycG9sYWJsZSA9IG5ldyBJbnRlcnBvbGFibGVTdHJpbmcoW2ludGVycG9sYWJsZSwgdW5pdEZvclByb3BlcnR5KGssIDApXSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5kUHJvcGVydGllc1trXSA9IGludGVycG9sYWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgaXNTVkcgPSBpc1NWR0VsZW1lbnQoZWwpO1xuICAgICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpO1xuICAgICAgICBtYXRyaXguYXBwbHlQcm9wZXJ0aWVzKHRyYW5zZm9ybXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9ICh0cmFuc2Zvcm1zLm1hcChmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtVmFsdWVGb3JQcm9wZXJ0eSh0cmFuc2Zvcm1bMF0sIHRyYW5zZm9ybVsxXSk7XG4gICAgICAgIH0pKS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWF0cml4ID0gTWF0cml4LmZyb21UcmFuc2Zvcm0oTWF0cml4Lm1hdHJpeEZvclRyYW5zZm9ybSh2KSk7XG4gICAgICB9XG4gICAgICBlbmRQcm9wZXJ0aWVzWyd0cmFuc2Zvcm0nXSA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcbiAgICAgIGlmIChpc1NWRykge1xuICAgICAgICBzdGFydFByb3BlcnRpZXMudHJhbnNmb3JtLmFwcGx5Um90YXRlQ2VudGVyKFtlbmRQcm9wZXJ0aWVzLnRyYW5zZm9ybS5wcm9wcy5yb3RhdGVbMV0sIGVuZFByb3BlcnRpZXMudHJhbnNmb3JtLnByb3BzLnJvdGF0ZVsyXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhbmltYXRpb25zLnB1c2goe1xuICAgICAgZWw6IGVsLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzdGFydDogc3RhcnRQcm9wZXJ0aWVzLFxuICAgICAgICBlbmQ6IGVuZFByb3BlcnRpZXNcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgY3VydmU6IG9wdGlvbnMudHlwZS5jYWxsKG9wdGlvbnMudHlwZSwgb3B0aW9ucylcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhcnRSdW5Mb29wKCk7XG4gIH07XG5cbiAgdGltZW91dHMgPSBbXTtcblxuICB0aW1lb3V0TGFzdElkID0gMDtcblxuICBzZXRSZWFsVGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgICBpZiAoIWlzRG9jdW1lbnRWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVvdXQucmVhbFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lb3V0LmZuKCk7XG4gICAgICByZXR1cm4gY2FuY2VsVGltZW91dCh0aW1lb3V0LmlkKTtcbiAgICB9LCB0aW1lb3V0LmRlbGF5KTtcbiAgfTtcblxuICBhZGRUaW1lb3V0ID0gZnVuY3Rpb24oZm4sIGRlbGF5KSB7XG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgdGltZW91dExhc3RJZCArPSAxO1xuICAgIHRpbWVvdXQgPSB7XG4gICAgICBpZDogdGltZW91dExhc3RJZCxcbiAgICAgIHRTdGFydDogRGF0ZS5ub3coKSxcbiAgICAgIGZuOiBmbixcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9yaWdpbmFsRGVsYXk6IGRlbGF5XG4gICAgfTtcbiAgICBzZXRSZWFsVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0cy5wdXNoKHRpbWVvdXQpO1xuICAgIHJldHVybiB0aW1lb3V0TGFzdElkO1xuICB9O1xuXG4gIGNhbmNlbFRpbWVvdXQgPSBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiB0aW1lb3V0cyA9IHRpbWVvdXRzLmZpbHRlcihmdW5jdGlvbih0aW1lb3V0KSB7XG4gICAgICBpZiAodGltZW91dC5pZCA9PT0gaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQucmVhbFRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZW91dC5pZCAhPT0gaWQ7XG4gICAgfSk7XG4gIH07XG5cbiAgbGVmdERlbGF5Rm9yVGltZW91dCA9IGZ1bmN0aW9uKHRpbWUsIHRpbWVvdXQpIHtcbiAgICB2YXIgY29uc3VtZWREZWxheTtcbiAgICBpZiAodGltZSAhPSBudWxsKSB7XG4gICAgICBjb25zdW1lZERlbGF5ID0gdGltZSAtIHRpbWVvdXQudFN0YXJ0O1xuICAgICAgcmV0dXJuIHRpbWVvdXQub3JpZ2luYWxEZWxheSAtIGNvbnN1bWVkRGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aW1lb3V0Lm9yaWdpbmFsRGVsYXk7XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBmdW5jdGlvbigpIHt9KTtcbiAgfVxuXG4gIHRpbWVCZWZvcmVWaXNpYmlsaXR5Q2hhbmdlID0gbnVsbDtcblxuICBvYnNlcnZlVmlzaWJpbGl0eUNoYW5nZShmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgdmFyIGFuaW1hdGlvbiwgZGlmZmVyZW5jZSwgdGltZW91dCwgX2ksIF9qLCBfaywgX2xlbiwgX2xlbjEsIF9sZW4yLCBfcmVzdWx0cztcbiAgICBydW5Mb29wUGF1c2VkID0gIXZpc2libGU7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICB0aW1lQmVmb3JlVmlzaWJpbGl0eUNoYW5nZSA9IERhdGUubm93KCk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0aW1lb3V0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB0aW1lb3V0ID0gdGltZW91dHNbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGNsZWFyVGltZW91dCh0aW1lb3V0LnJlYWxUaW1lb3V0SWQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJ1bkxvb3BSdW5uaW5nKSB7XG4gICAgICAgIGRpZmZlcmVuY2UgPSBEYXRlLm5vdygpIC0gdGltZUJlZm9yZVZpc2liaWxpdHlDaGFuZ2U7XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGFuaW1hdGlvbnMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1tfal07XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbi50U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLnRTdGFydCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gdGltZW91dHMubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgIHRpbWVvdXQgPSB0aW1lb3V0c1tfa107XG4gICAgICAgIHRpbWVvdXQuZGVsYXkgPSBsZWZ0RGVsYXlGb3JUaW1lb3V0KHRpbWVCZWZvcmVWaXNpYmlsaXR5Q2hhbmdlLCB0aW1lb3V0KTtcbiAgICAgICAgc2V0UmVhbFRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZUJlZm9yZVZpc2liaWxpdHlDaGFuZ2UgPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgZHluYW1pY3MgPSB7fTtcblxuICBkeW5hbWljcy5saW5lYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgfTtcblxuICBkeW5hbWljcy5zcHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIEExLCBBMiwgZGVjYWwsIGZyZXF1ZW5jeSwgZnJpY3Rpb24sIHM7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBhcHBseURlZmF1bHRzKG9wdGlvbnMsIGR5bmFtaWNzLnNwcmluZy5kZWZhdWx0cyk7XG4gICAgZnJlcXVlbmN5ID0gTWF0aC5tYXgoMSwgb3B0aW9ucy5mcmVxdWVuY3kgLyAyMCk7XG4gICAgZnJpY3Rpb24gPSBNYXRoLnBvdygyMCwgb3B0aW9ucy5mcmljdGlvbiAvIDEwMCk7XG4gICAgcyA9IG9wdGlvbnMuYW50aWNpcGF0aW9uU2l6ZSAvIDEwMDA7XG4gICAgZGVjYWwgPSBNYXRoLm1heCgwLCBzKTtcbiAgICBBMSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBNLCBhLCBiLCB4MCwgeDE7XG4gICAgICBNID0gMC44O1xuICAgICAgeDAgPSBzIC8gKDEgLSBzKTtcbiAgICAgIHgxID0gMDtcbiAgICAgIGIgPSAoeDAgLSAoTSAqIHgxKSkgLyAoeDAgLSB4MSk7XG4gICAgICBhID0gKE0gLSBiKSAvIHgwO1xuICAgICAgcmV0dXJuIChhICogdCAqIG9wdGlvbnMuYW50aWNpcGF0aW9uU3RyZW5ndGggLyAxMDApICsgYjtcbiAgICB9O1xuICAgIEEyID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KGZyaWN0aW9uIC8gMTAsIC10KSAqICgxIC0gdCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIEEsIEF0LCBhLCBhbmdsZSwgYiwgZnJpY3Rpb25ULCB5MCwgeVM7XG4gICAgICBmcmljdGlvblQgPSAodCAvICgxIC0gcykpIC0gKHMgLyAoMSAtIHMpKTtcbiAgICAgIGlmICh0IDwgcykge1xuICAgICAgICB5UyA9IChzIC8gKDEgLSBzKSkgLSAocyAvICgxIC0gcykpO1xuICAgICAgICB5MCA9ICgwIC8gKDEgLSBzKSkgLSAocyAvICgxIC0gcykpO1xuICAgICAgICBiID0gTWF0aC5hY29zKDEgLyBBMSh5UykpO1xuICAgICAgICBhID0gKE1hdGguYWNvcygxIC8gQTEoeTApKSAtIGIpIC8gKGZyZXF1ZW5jeSAqICgtcykpO1xuICAgICAgICBBID0gQTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBID0gQTI7XG4gICAgICAgIGIgPSAwO1xuICAgICAgICBhID0gMTtcbiAgICAgIH1cbiAgICAgIEF0ID0gQShmcmljdGlvblQpO1xuICAgICAgYW5nbGUgPSBmcmVxdWVuY3kgKiAodCAtIHMpICogYSArIGI7XG4gICAgICByZXR1cm4gMSAtIChBdCAqIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgfTtcbiAgfTtcblxuICBkeW5hbWljcy5ib3VuY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIEEsIGZuLCBmcmVxdWVuY3ksIGZyaWN0aW9uO1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgYXBwbHlEZWZhdWx0cyhvcHRpb25zLCBkeW5hbWljcy5ib3VuY2UuZGVmYXVsdHMpO1xuICAgIGZyZXF1ZW5jeSA9IE1hdGgubWF4KDEsIG9wdGlvbnMuZnJlcXVlbmN5IC8gMjApO1xuICAgIGZyaWN0aW9uID0gTWF0aC5wb3coMjAsIG9wdGlvbnMuZnJpY3Rpb24gLyAxMDApO1xuICAgIEEgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coZnJpY3Rpb24gLyAxMCwgLXQpICogKDEgLSB0KTtcbiAgICB9O1xuICAgIGZuID0gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIEF0LCBhLCBhbmdsZSwgYjtcbiAgICAgIGIgPSAtMy4xNCAvIDI7XG4gICAgICBhID0gMTtcbiAgICAgIEF0ID0gQSh0KTtcbiAgICAgIGFuZ2xlID0gZnJlcXVlbmN5ICogdCAqIGEgKyBiO1xuICAgICAgcmV0dXJuIEF0ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIH07XG4gICAgZm4ucmV0dXJuc1RvU2VsZiA9IHRydWU7XG4gICAgcmV0dXJuIGZuO1xuICB9O1xuXG4gIGR5bmFtaWNzLmdyYXZpdHkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIEwsIGJvdW5jaW5lc3MsIGN1cnZlcywgZWxhc3RpY2l0eSwgZm4sIGdldFBvaW50SW5DdXJ2ZSwgZ3Jhdml0eTtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGFwcGx5RGVmYXVsdHMob3B0aW9ucywgZHluYW1pY3MuZ3Jhdml0eS5kZWZhdWx0cyk7XG4gICAgYm91bmNpbmVzcyA9IE1hdGgubWluKG9wdGlvbnMuYm91bmNpbmVzcyAvIDEyNTAsIDAuOCk7XG4gICAgZWxhc3RpY2l0eSA9IG9wdGlvbnMuZWxhc3RpY2l0eSAvIDEwMDA7XG4gICAgZ3Jhdml0eSA9IDEwMDtcbiAgICBjdXJ2ZXMgPSBbXTtcbiAgICBMID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGIsIGN1cnZlO1xuICAgICAgYiA9IE1hdGguc3FydCgyIC8gZ3Jhdml0eSk7XG4gICAgICBjdXJ2ZSA9IHtcbiAgICAgICAgYTogLWIsXG4gICAgICAgIGI6IGIsXG4gICAgICAgIEg6IDFcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5zVG9TZWxmKSB7XG4gICAgICAgIGN1cnZlLmEgPSAwO1xuICAgICAgICBjdXJ2ZS5iID0gY3VydmUuYiAqIDI7XG4gICAgICB9XG4gICAgICB3aGlsZSAoY3VydmUuSCA+IDAuMDAxKSB7XG4gICAgICAgIEwgPSBjdXJ2ZS5iIC0gY3VydmUuYTtcbiAgICAgICAgY3VydmUgPSB7XG4gICAgICAgICAgYTogY3VydmUuYixcbiAgICAgICAgICBiOiBjdXJ2ZS5iICsgTCAqIGJvdW5jaW5lc3MsXG4gICAgICAgICAgSDogY3VydmUuSCAqIGJvdW5jaW5lc3MgKiBib3VuY2luZXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VydmUuYjtcbiAgICB9KSgpO1xuICAgIGdldFBvaW50SW5DdXJ2ZSA9IGZ1bmN0aW9uKGEsIGIsIEgsIHQpIHtcbiAgICAgIHZhciBjLCB0MjtcbiAgICAgIEwgPSBiIC0gYTtcbiAgICAgIHQyID0gKDIgLyBMKSAqIHQgLSAxIC0gKGEgKiAyIC8gTCk7XG4gICAgICBjID0gdDIgKiB0MiAqIEggLSBIICsgMTtcbiAgICAgIGlmIChvcHRpb25zLnJldHVybnNUb1NlbGYpIHtcbiAgICAgICAgYyA9IDEgLSBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgTDIsIGIsIGN1cnZlLCBfcmVzdWx0cztcbiAgICAgIGIgPSBNYXRoLnNxcnQoMiAvIChncmF2aXR5ICogTCAqIEwpKTtcbiAgICAgIGN1cnZlID0ge1xuICAgICAgICBhOiAtYixcbiAgICAgICAgYjogYixcbiAgICAgICAgSDogMVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLnJldHVybnNUb1NlbGYpIHtcbiAgICAgICAgY3VydmUuYSA9IDA7XG4gICAgICAgIGN1cnZlLmIgPSBjdXJ2ZS5iICogMjtcbiAgICAgIH1cbiAgICAgIGN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgIEwyID0gTDtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAoY3VydmUuYiA8IDEgJiYgY3VydmUuSCA+IDAuMDAxKSB7XG4gICAgICAgIEwyID0gY3VydmUuYiAtIGN1cnZlLmE7XG4gICAgICAgIGN1cnZlID0ge1xuICAgICAgICAgIGE6IGN1cnZlLmIsXG4gICAgICAgICAgYjogY3VydmUuYiArIEwyICogYm91bmNpbmVzcyxcbiAgICAgICAgICBIOiBjdXJ2ZS5IICogZWxhc3RpY2l0eVxuICAgICAgICB9O1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGN1cnZlcy5wdXNoKGN1cnZlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKTtcbiAgICBmbiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBjdXJ2ZSwgaSwgdjtcbiAgICAgIGkgPSAwO1xuICAgICAgY3VydmUgPSBjdXJ2ZXNbaV07XG4gICAgICB3aGlsZSAoISh0ID49IGN1cnZlLmEgJiYgdCA8PSBjdXJ2ZS5iKSkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGN1cnZlID0gY3VydmVzW2ldO1xuICAgICAgICBpZiAoIWN1cnZlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY3VydmUpIHtcbiAgICAgICAgdiA9IG9wdGlvbnMucmV0dXJuc1RvU2VsZiA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IGdldFBvaW50SW5DdXJ2ZShjdXJ2ZS5hLCBjdXJ2ZS5iLCBjdXJ2ZS5ILCB0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgZm4ucmV0dXJuc1RvU2VsZiA9IG9wdGlvbnMucmV0dXJuc1RvU2VsZjtcbiAgICByZXR1cm4gZm47XG4gIH07XG5cbiAgZHluYW1pY3MuZm9yY2VXaXRoR3Jhdml0eSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGFwcGx5RGVmYXVsdHMob3B0aW9ucywgZHluYW1pY3MuZm9yY2VXaXRoR3Jhdml0eS5kZWZhdWx0cyk7XG4gICAgb3B0aW9ucy5yZXR1cm5zVG9TZWxmID0gdHJ1ZTtcbiAgICByZXR1cm4gZHluYW1pY3MuZ3Jhdml0eShvcHRpb25zKTtcbiAgfTtcblxuICBkeW5hbWljcy5iZXppZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJlemllciwgQmV6aWVyXywgeUZvclg7XG4gICAgQmV6aWVyXyA9IGZ1bmN0aW9uKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICByZXR1cm4gKE1hdGgucG93KDEgLSB0LCAzKSAqIHAwKSArICgzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHAxKSArICgzICogKDEgLSB0KSAqIE1hdGgucG93KHQsIDIpICogcDIpICsgTWF0aC5wb3codCwgMykgKiBwMztcbiAgICB9O1xuICAgIEJlemllciA9IGZ1bmN0aW9uKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBCZXppZXJfKHQsIHAwLngsIHAxLngsIHAyLngsIHAzLngpLFxuICAgICAgICB5OiBCZXppZXJfKHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkpXG4gICAgICB9O1xuICAgIH07XG4gICAgeUZvclggPSBmdW5jdGlvbih4VGFyZ2V0LCBCcywgcmV0dXJuc1RvU2VsZikge1xuICAgICAgdmFyIEIsIGFCLCBpLCBsb3dlciwgcGVyY2VudCwgdXBwZXIsIHgsIHhUb2xlcmFuY2UsIF9pLCBfbGVuO1xuICAgICAgQiA9IG51bGw7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IEJzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGFCID0gQnNbX2ldO1xuICAgICAgICBpZiAoeFRhcmdldCA+PSBhQigwKS54ICYmIHhUYXJnZXQgPD0gYUIoMSkueCkge1xuICAgICAgICAgIEIgPSBhQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQiAhPT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIUIpIHtcbiAgICAgICAgaWYgKHJldHVybnNUb1NlbGYpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeFRvbGVyYW5jZSA9IDAuMDAwMTtcbiAgICAgIGxvd2VyID0gMDtcbiAgICAgIHVwcGVyID0gMTtcbiAgICAgIHBlcmNlbnQgPSAodXBwZXIgKyBsb3dlcikgLyAyO1xuICAgICAgeCA9IEIocGVyY2VudCkueDtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKE1hdGguYWJzKHhUYXJnZXQgLSB4KSA+IHhUb2xlcmFuY2UgJiYgaSA8IDEwMCkge1xuICAgICAgICBpZiAoeFRhcmdldCA+IHgpIHtcbiAgICAgICAgICBsb3dlciA9IHBlcmNlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSBwZXJjZW50O1xuICAgICAgICB9XG4gICAgICAgIHBlcmNlbnQgPSAodXBwZXIgKyBsb3dlcikgLyAyO1xuICAgICAgICB4ID0gQihwZXJjZW50KS54O1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQihwZXJjZW50KS55O1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBCcywgZm4sIHBvaW50cztcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgcG9pbnRzID0gb3B0aW9ucy5wb2ludHM7XG4gICAgICBCcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGssIF9mbjtcbiAgICAgICAgQnMgPSBbXTtcbiAgICAgICAgX2ZuID0gZnVuY3Rpb24ocG9pbnRBLCBwb2ludEIpIHtcbiAgICAgICAgICB2YXIgQjI7XG4gICAgICAgICAgQjIgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gQmV6aWVyKHQsIHBvaW50QSwgcG9pbnRBLmNwW3BvaW50QS5jcC5sZW5ndGggLSAxXSwgcG9pbnRCLmNwWzBdLCBwb2ludEIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIEJzLnB1c2goQjIpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGkgaW4gcG9pbnRzKSB7XG4gICAgICAgICAgayA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgIGlmIChrID49IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZuKHBvaW50c1trXSwgcG9pbnRzW2sgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJzO1xuICAgICAgfSkoKTtcbiAgICAgIGZuID0gZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geUZvclgodCwgQnMsIHRoaXMucmV0dXJuc1RvU2VsZik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmbi5yZXR1cm5zVG9TZWxmID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS55ID09PSAwO1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZHluYW1pY3MuZWFzZUluT3V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBmcmljdGlvbiwgX3JlZjtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGZyaWN0aW9uID0gKF9yZWYgPSBvcHRpb25zLmZyaWN0aW9uKSAhPSBudWxsID8gX3JlZiA6IGR5bmFtaWNzLmVhc2VJbk91dC5kZWZhdWx0cy5mcmljdGlvbjtcbiAgICByZXR1cm4gZHluYW1pY3MuYmV6aWVyKHtcbiAgICAgIHBvaW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIGNwOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IDAuOTIgLSAoZnJpY3Rpb24gLyAxMDAwKSxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgeTogMSxcbiAgICAgICAgICBjcDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAwLjA4ICsgKGZyaWN0aW9uIC8gMTAwMCksXG4gICAgICAgICAgICAgIHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfTtcblxuICBkeW5hbWljcy5lYXNlSW4gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGZyaWN0aW9uLCBfcmVmO1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgZnJpY3Rpb24gPSAoX3JlZiA9IG9wdGlvbnMuZnJpY3Rpb24pICE9IG51bGwgPyBfcmVmIDogZHluYW1pY3MuZWFzZUluLmRlZmF1bHRzLmZyaWN0aW9uO1xuICAgIHJldHVybiBkeW5hbWljcy5iZXppZXIoe1xuICAgICAgcG9pbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgY3A6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogMC45MiAtIChmcmljdGlvbiAvIDEwMDApLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogMSxcbiAgICAgICAgICB5OiAxLFxuICAgICAgICAgIGNwOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgICAgIHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfTtcblxuICBkeW5hbWljcy5lYXNlT3V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBmcmljdGlvbiwgX3JlZjtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGZyaWN0aW9uID0gKF9yZWYgPSBvcHRpb25zLmZyaWN0aW9uKSAhPSBudWxsID8gX3JlZiA6IGR5bmFtaWNzLmVhc2VPdXQuZGVmYXVsdHMuZnJpY3Rpb247XG4gICAgcmV0dXJuIGR5bmFtaWNzLmJlemllcih7XG4gICAgICBwb2ludHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBjcDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogMSxcbiAgICAgICAgICB5OiAxLFxuICAgICAgICAgIGNwOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IDAuMDggKyAoZnJpY3Rpb24gLyAxMDAwKSxcbiAgICAgICAgICAgICAgeTogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9O1xuXG4gIGR5bmFtaWNzLnNwcmluZy5kZWZhdWx0cyA9IHtcbiAgICBmcmVxdWVuY3k6IDMwMCxcbiAgICBmcmljdGlvbjogMjAwLFxuICAgIGFudGljaXBhdGlvblNpemU6IDAsXG4gICAgYW50aWNpcGF0aW9uU3RyZW5ndGg6IDBcbiAgfTtcblxuICBkeW5hbWljcy5ib3VuY2UuZGVmYXVsdHMgPSB7XG4gICAgZnJlcXVlbmN5OiAzMDAsXG4gICAgZnJpY3Rpb246IDIwMFxuICB9O1xuXG4gIGR5bmFtaWNzLmZvcmNlV2l0aEdyYXZpdHkuZGVmYXVsdHMgPSBkeW5hbWljcy5ncmF2aXR5LmRlZmF1bHRzID0ge1xuICAgIGJvdW5jaW5lc3M6IDQwMCxcbiAgICBlbGFzdGljaXR5OiAyMDBcbiAgfTtcblxuICBkeW5hbWljcy5lYXNlSW5PdXQuZGVmYXVsdHMgPSBkeW5hbWljcy5lYXNlSW4uZGVmYXVsdHMgPSBkeW5hbWljcy5lYXNlT3V0LmRlZmF1bHRzID0ge1xuICAgIGZyaWN0aW9uOiA1MDBcbiAgfTtcblxuICBkeW5hbWljcy5jc3MgPSBtYWtlQXJyYXlGbihmdW5jdGlvbihlbCwgcHJvcGVydGllcykge1xuICAgIHJldHVybiBhcHBseVByb3BlcnRpZXMoZWwsIHByb3BlcnRpZXMsIHRydWUpO1xuICB9KTtcblxuICBkeW5hbWljcy5hbmltYXRlID0gbWFrZUFycmF5Rm4oZnVuY3Rpb24oZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaWQ7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XG4gICAgYXBwbHlEZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICB0eXBlOiBkeW5hbWljcy5lYXNlSW5PdXQsXG4gICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgIGRlbGF5OiAwLFxuICAgICAgYW5pbWF0ZWQ6IHRydWVcbiAgICB9KTtcbiAgICBvcHRpb25zLmR1cmF0aW9uID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5kdXJhdGlvbiAqIHNsb3dSYXRpbyk7XG4gICAgb3B0aW9ucy5kZWxheSA9IE1hdGgubWF4KDAsIG9wdGlvbnMuZGVsYXkpO1xuICAgIGlmIChvcHRpb25zLmRlbGF5ID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RhcnRBbmltYXRpb24oZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IGR5bmFtaWNzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdGFydEFuaW1hdGlvbihlbCwgcHJvcGVydGllcywgb3B0aW9ucywgaWQpO1xuICAgICAgfSwgb3B0aW9ucy5kZWxheSk7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uc1RpbWVvdXRzLnB1c2goe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGVsOiBlbFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBkeW5hbWljcy5zdG9wID0gbWFrZUFycmF5Rm4oZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgYW5pbWF0aW9uc1RpbWVvdXRzID0gYW5pbWF0aW9uc1RpbWVvdXRzLmZpbHRlcihmdW5jdGlvbih0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0LmVsID09PSBlbCAmJiAoKG9wdGlvbnMuZmlsdGVyID09IG51bGwpIHx8IG9wdGlvbnMuZmlsdGVyKHRpbWVvdXQpKSkge1xuICAgICAgICAgIGR5bmFtaWNzLmNsZWFyVGltZW91dCh0aW1lb3V0LmlkKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgIHJldHVybiBhbmltYXRpb24uZWwgIT09IGVsO1xuICAgIH0pO1xuICB9KTtcblxuICBkeW5hbWljcy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oZm4sIGRlbGF5KSB7XG4gICAgcmV0dXJuIGFkZFRpbWVvdXQoZm4sIGRlbGF5ICogc2xvd1JhdGlvKTtcbiAgfTtcblxuICBkeW5hbWljcy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjYW5jZWxUaW1lb3V0KGlkKTtcbiAgfTtcblxuICBkeW5hbWljcy50b2dnbGVTbG93ID0gZnVuY3Rpb24oKSB7XG4gICAgc2xvdyA9ICFzbG93O1xuICAgIGlmIChzbG93KSB7XG4gICAgICBzbG93UmF0aW8gPSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbG93UmF0aW8gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZSAhPT0gbnVsbCA/IHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiID8gY29uc29sZS5sb2coXCJkeW5hbWljcy5qczogc2xvdyBhbmltYXRpb25zIFwiICsgKHNsb3cgPyBcImVuYWJsZWRcIiA6IFwiZGlzYWJsZWRcIikpIDogdm9pZCAwIDogdm9pZCAwO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZHluYW1pY3M7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGVmaW5lKCdkeW5hbWljcycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGR5bmFtaWNzO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5keW5hbWljcyA9IGR5bmFtaWNzO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBhcHAvcHVibGljL2Jvd2VyX2NvbXBvbmVudHMvZHluYW1pY3MuanMvbGliL2R5bmFtaWNzLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuICoqLyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBO0FBQ0E7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBOztBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFKQTtBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUpBO0FBWEE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFKQTtBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUpBO0FBWEE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFKQTtBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUpBO0FBWEE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQ3JnRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9